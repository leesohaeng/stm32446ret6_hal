
C:\Users\sohae\Desktop\STM32F446RET6_HAL\CZY\Debug\CZY.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001c20  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000034  08001ce0  08001ce0  00011ce0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08001d14  08001d14  00011d14  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08001d1c  08001d1c  00011d1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08001d20  08001d20  00011d20  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000004  20000000  08001d24  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000090  20000004  08001d28  00020004  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20000094  08001d28  00020094  2**0
                  ALLOC
  9 .ARM.attributes 00000028  00000000  00000000  00020004  2**0
                  CONTENTS, READONLY
 10 .debug_info   000074e3  00000000  00000000  0002002c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000182f  00000000  00000000  0002750f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003181  00000000  00000000  00028d3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000600  00000000  00000000  0002bec0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000628  00000000  00000000  0002c4c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00003721  00000000  00000000  0002cae8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000021a1  00000000  00000000  00030209  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  000323aa  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00000f94  00000000  00000000  00032428  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000004 	.word	0x20000004
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08001cc8 	.word	0x08001cc8

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000008 	.word	0x20000008
 8000104:	08001cc8 	.word	0x08001cc8

08000108 <__gnu_thumb1_case_uqi>:
 8000108:	b402      	push	{r1}
 800010a:	4671      	mov	r1, lr
 800010c:	0849      	lsrs	r1, r1, #1
 800010e:	0049      	lsls	r1, r1, #1
 8000110:	5c09      	ldrb	r1, [r1, r0]
 8000112:	0049      	lsls	r1, r1, #1
 8000114:	448e      	add	lr, r1
 8000116:	bc02      	pop	{r1}
 8000118:	4770      	bx	lr
 800011a:	46c0      	nop			; (mov r8, r8)

0800011c <__aeabi_uidiv>:
 800011c:	2200      	movs	r2, #0
 800011e:	0843      	lsrs	r3, r0, #1
 8000120:	428b      	cmp	r3, r1
 8000122:	d374      	bcc.n	800020e <__aeabi_uidiv+0xf2>
 8000124:	0903      	lsrs	r3, r0, #4
 8000126:	428b      	cmp	r3, r1
 8000128:	d35f      	bcc.n	80001ea <__aeabi_uidiv+0xce>
 800012a:	0a03      	lsrs	r3, r0, #8
 800012c:	428b      	cmp	r3, r1
 800012e:	d344      	bcc.n	80001ba <__aeabi_uidiv+0x9e>
 8000130:	0b03      	lsrs	r3, r0, #12
 8000132:	428b      	cmp	r3, r1
 8000134:	d328      	bcc.n	8000188 <__aeabi_uidiv+0x6c>
 8000136:	0c03      	lsrs	r3, r0, #16
 8000138:	428b      	cmp	r3, r1
 800013a:	d30d      	bcc.n	8000158 <__aeabi_uidiv+0x3c>
 800013c:	22ff      	movs	r2, #255	; 0xff
 800013e:	0209      	lsls	r1, r1, #8
 8000140:	ba12      	rev	r2, r2
 8000142:	0c03      	lsrs	r3, r0, #16
 8000144:	428b      	cmp	r3, r1
 8000146:	d302      	bcc.n	800014e <__aeabi_uidiv+0x32>
 8000148:	1212      	asrs	r2, r2, #8
 800014a:	0209      	lsls	r1, r1, #8
 800014c:	d065      	beq.n	800021a <__aeabi_uidiv+0xfe>
 800014e:	0b03      	lsrs	r3, r0, #12
 8000150:	428b      	cmp	r3, r1
 8000152:	d319      	bcc.n	8000188 <__aeabi_uidiv+0x6c>
 8000154:	e000      	b.n	8000158 <__aeabi_uidiv+0x3c>
 8000156:	0a09      	lsrs	r1, r1, #8
 8000158:	0bc3      	lsrs	r3, r0, #15
 800015a:	428b      	cmp	r3, r1
 800015c:	d301      	bcc.n	8000162 <__aeabi_uidiv+0x46>
 800015e:	03cb      	lsls	r3, r1, #15
 8000160:	1ac0      	subs	r0, r0, r3
 8000162:	4152      	adcs	r2, r2
 8000164:	0b83      	lsrs	r3, r0, #14
 8000166:	428b      	cmp	r3, r1
 8000168:	d301      	bcc.n	800016e <__aeabi_uidiv+0x52>
 800016a:	038b      	lsls	r3, r1, #14
 800016c:	1ac0      	subs	r0, r0, r3
 800016e:	4152      	adcs	r2, r2
 8000170:	0b43      	lsrs	r3, r0, #13
 8000172:	428b      	cmp	r3, r1
 8000174:	d301      	bcc.n	800017a <__aeabi_uidiv+0x5e>
 8000176:	034b      	lsls	r3, r1, #13
 8000178:	1ac0      	subs	r0, r0, r3
 800017a:	4152      	adcs	r2, r2
 800017c:	0b03      	lsrs	r3, r0, #12
 800017e:	428b      	cmp	r3, r1
 8000180:	d301      	bcc.n	8000186 <__aeabi_uidiv+0x6a>
 8000182:	030b      	lsls	r3, r1, #12
 8000184:	1ac0      	subs	r0, r0, r3
 8000186:	4152      	adcs	r2, r2
 8000188:	0ac3      	lsrs	r3, r0, #11
 800018a:	428b      	cmp	r3, r1
 800018c:	d301      	bcc.n	8000192 <__aeabi_uidiv+0x76>
 800018e:	02cb      	lsls	r3, r1, #11
 8000190:	1ac0      	subs	r0, r0, r3
 8000192:	4152      	adcs	r2, r2
 8000194:	0a83      	lsrs	r3, r0, #10
 8000196:	428b      	cmp	r3, r1
 8000198:	d301      	bcc.n	800019e <__aeabi_uidiv+0x82>
 800019a:	028b      	lsls	r3, r1, #10
 800019c:	1ac0      	subs	r0, r0, r3
 800019e:	4152      	adcs	r2, r2
 80001a0:	0a43      	lsrs	r3, r0, #9
 80001a2:	428b      	cmp	r3, r1
 80001a4:	d301      	bcc.n	80001aa <__aeabi_uidiv+0x8e>
 80001a6:	024b      	lsls	r3, r1, #9
 80001a8:	1ac0      	subs	r0, r0, r3
 80001aa:	4152      	adcs	r2, r2
 80001ac:	0a03      	lsrs	r3, r0, #8
 80001ae:	428b      	cmp	r3, r1
 80001b0:	d301      	bcc.n	80001b6 <__aeabi_uidiv+0x9a>
 80001b2:	020b      	lsls	r3, r1, #8
 80001b4:	1ac0      	subs	r0, r0, r3
 80001b6:	4152      	adcs	r2, r2
 80001b8:	d2cd      	bcs.n	8000156 <__aeabi_uidiv+0x3a>
 80001ba:	09c3      	lsrs	r3, r0, #7
 80001bc:	428b      	cmp	r3, r1
 80001be:	d301      	bcc.n	80001c4 <__aeabi_uidiv+0xa8>
 80001c0:	01cb      	lsls	r3, r1, #7
 80001c2:	1ac0      	subs	r0, r0, r3
 80001c4:	4152      	adcs	r2, r2
 80001c6:	0983      	lsrs	r3, r0, #6
 80001c8:	428b      	cmp	r3, r1
 80001ca:	d301      	bcc.n	80001d0 <__aeabi_uidiv+0xb4>
 80001cc:	018b      	lsls	r3, r1, #6
 80001ce:	1ac0      	subs	r0, r0, r3
 80001d0:	4152      	adcs	r2, r2
 80001d2:	0943      	lsrs	r3, r0, #5
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d301      	bcc.n	80001dc <__aeabi_uidiv+0xc0>
 80001d8:	014b      	lsls	r3, r1, #5
 80001da:	1ac0      	subs	r0, r0, r3
 80001dc:	4152      	adcs	r2, r2
 80001de:	0903      	lsrs	r3, r0, #4
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d301      	bcc.n	80001e8 <__aeabi_uidiv+0xcc>
 80001e4:	010b      	lsls	r3, r1, #4
 80001e6:	1ac0      	subs	r0, r0, r3
 80001e8:	4152      	adcs	r2, r2
 80001ea:	08c3      	lsrs	r3, r0, #3
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d301      	bcc.n	80001f4 <__aeabi_uidiv+0xd8>
 80001f0:	00cb      	lsls	r3, r1, #3
 80001f2:	1ac0      	subs	r0, r0, r3
 80001f4:	4152      	adcs	r2, r2
 80001f6:	0883      	lsrs	r3, r0, #2
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d301      	bcc.n	8000200 <__aeabi_uidiv+0xe4>
 80001fc:	008b      	lsls	r3, r1, #2
 80001fe:	1ac0      	subs	r0, r0, r3
 8000200:	4152      	adcs	r2, r2
 8000202:	0843      	lsrs	r3, r0, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d301      	bcc.n	800020c <__aeabi_uidiv+0xf0>
 8000208:	004b      	lsls	r3, r1, #1
 800020a:	1ac0      	subs	r0, r0, r3
 800020c:	4152      	adcs	r2, r2
 800020e:	1a41      	subs	r1, r0, r1
 8000210:	d200      	bcs.n	8000214 <__aeabi_uidiv+0xf8>
 8000212:	4601      	mov	r1, r0
 8000214:	4152      	adcs	r2, r2
 8000216:	4610      	mov	r0, r2
 8000218:	4770      	bx	lr
 800021a:	e7ff      	b.n	800021c <__aeabi_uidiv+0x100>
 800021c:	b501      	push	{r0, lr}
 800021e:	2000      	movs	r0, #0
 8000220:	f000 f806 	bl	8000230 <__aeabi_idiv0>
 8000224:	bd02      	pop	{r1, pc}
 8000226:	46c0      	nop			; (mov r8, r8)

08000228 <__aeabi_uidivmod>:
 8000228:	2900      	cmp	r1, #0
 800022a:	d0f7      	beq.n	800021c <__aeabi_uidiv+0x100>
 800022c:	e776      	b.n	800011c <__aeabi_uidiv>
 800022e:	4770      	bx	lr

08000230 <__aeabi_idiv0>:
 8000230:	4770      	bx	lr
 8000232:	46c0      	nop			; (mov r8, r8)

08000234 <__aeabi_uldivmod>:
 8000234:	2b00      	cmp	r3, #0
 8000236:	d111      	bne.n	800025c <__aeabi_uldivmod+0x28>
 8000238:	2a00      	cmp	r2, #0
 800023a:	d10f      	bne.n	800025c <__aeabi_uldivmod+0x28>
 800023c:	2900      	cmp	r1, #0
 800023e:	d100      	bne.n	8000242 <__aeabi_uldivmod+0xe>
 8000240:	2800      	cmp	r0, #0
 8000242:	d002      	beq.n	800024a <__aeabi_uldivmod+0x16>
 8000244:	2100      	movs	r1, #0
 8000246:	43c9      	mvns	r1, r1
 8000248:	1c08      	adds	r0, r1, #0
 800024a:	b407      	push	{r0, r1, r2}
 800024c:	4802      	ldr	r0, [pc, #8]	; (8000258 <__aeabi_uldivmod+0x24>)
 800024e:	a102      	add	r1, pc, #8	; (adr r1, 8000258 <__aeabi_uldivmod+0x24>)
 8000250:	1840      	adds	r0, r0, r1
 8000252:	9002      	str	r0, [sp, #8]
 8000254:	bd03      	pop	{r0, r1, pc}
 8000256:	46c0      	nop			; (mov r8, r8)
 8000258:	ffffffd9 	.word	0xffffffd9
 800025c:	b403      	push	{r0, r1}
 800025e:	4668      	mov	r0, sp
 8000260:	b501      	push	{r0, lr}
 8000262:	9802      	ldr	r0, [sp, #8]
 8000264:	f000 f806 	bl	8000274 <__udivmoddi4>
 8000268:	9b01      	ldr	r3, [sp, #4]
 800026a:	469e      	mov	lr, r3
 800026c:	b002      	add	sp, #8
 800026e:	bc0c      	pop	{r2, r3}
 8000270:	4770      	bx	lr
 8000272:	46c0      	nop			; (mov r8, r8)

08000274 <__udivmoddi4>:
 8000274:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000276:	464d      	mov	r5, r9
 8000278:	4656      	mov	r6, sl
 800027a:	4644      	mov	r4, r8
 800027c:	465f      	mov	r7, fp
 800027e:	b4f0      	push	{r4, r5, r6, r7}
 8000280:	4692      	mov	sl, r2
 8000282:	b083      	sub	sp, #12
 8000284:	0004      	movs	r4, r0
 8000286:	000d      	movs	r5, r1
 8000288:	4699      	mov	r9, r3
 800028a:	428b      	cmp	r3, r1
 800028c:	d82f      	bhi.n	80002ee <__udivmoddi4+0x7a>
 800028e:	d02c      	beq.n	80002ea <__udivmoddi4+0x76>
 8000290:	4649      	mov	r1, r9
 8000292:	4650      	mov	r0, sl
 8000294:	f000 f8ae 	bl	80003f4 <__clzdi2>
 8000298:	0029      	movs	r1, r5
 800029a:	0006      	movs	r6, r0
 800029c:	0020      	movs	r0, r4
 800029e:	f000 f8a9 	bl	80003f4 <__clzdi2>
 80002a2:	1a33      	subs	r3, r6, r0
 80002a4:	4698      	mov	r8, r3
 80002a6:	3b20      	subs	r3, #32
 80002a8:	469b      	mov	fp, r3
 80002aa:	d500      	bpl.n	80002ae <__udivmoddi4+0x3a>
 80002ac:	e074      	b.n	8000398 <__udivmoddi4+0x124>
 80002ae:	4653      	mov	r3, sl
 80002b0:	465a      	mov	r2, fp
 80002b2:	4093      	lsls	r3, r2
 80002b4:	001f      	movs	r7, r3
 80002b6:	4653      	mov	r3, sl
 80002b8:	4642      	mov	r2, r8
 80002ba:	4093      	lsls	r3, r2
 80002bc:	001e      	movs	r6, r3
 80002be:	42af      	cmp	r7, r5
 80002c0:	d829      	bhi.n	8000316 <__udivmoddi4+0xa2>
 80002c2:	d026      	beq.n	8000312 <__udivmoddi4+0x9e>
 80002c4:	465b      	mov	r3, fp
 80002c6:	1ba4      	subs	r4, r4, r6
 80002c8:	41bd      	sbcs	r5, r7
 80002ca:	2b00      	cmp	r3, #0
 80002cc:	da00      	bge.n	80002d0 <__udivmoddi4+0x5c>
 80002ce:	e079      	b.n	80003c4 <__udivmoddi4+0x150>
 80002d0:	2200      	movs	r2, #0
 80002d2:	2300      	movs	r3, #0
 80002d4:	9200      	str	r2, [sp, #0]
 80002d6:	9301      	str	r3, [sp, #4]
 80002d8:	2301      	movs	r3, #1
 80002da:	465a      	mov	r2, fp
 80002dc:	4093      	lsls	r3, r2
 80002de:	9301      	str	r3, [sp, #4]
 80002e0:	2301      	movs	r3, #1
 80002e2:	4642      	mov	r2, r8
 80002e4:	4093      	lsls	r3, r2
 80002e6:	9300      	str	r3, [sp, #0]
 80002e8:	e019      	b.n	800031e <__udivmoddi4+0xaa>
 80002ea:	4282      	cmp	r2, r0
 80002ec:	d9d0      	bls.n	8000290 <__udivmoddi4+0x1c>
 80002ee:	2200      	movs	r2, #0
 80002f0:	2300      	movs	r3, #0
 80002f2:	9200      	str	r2, [sp, #0]
 80002f4:	9301      	str	r3, [sp, #4]
 80002f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80002f8:	2b00      	cmp	r3, #0
 80002fa:	d001      	beq.n	8000300 <__udivmoddi4+0x8c>
 80002fc:	601c      	str	r4, [r3, #0]
 80002fe:	605d      	str	r5, [r3, #4]
 8000300:	9800      	ldr	r0, [sp, #0]
 8000302:	9901      	ldr	r1, [sp, #4]
 8000304:	b003      	add	sp, #12
 8000306:	bc3c      	pop	{r2, r3, r4, r5}
 8000308:	4690      	mov	r8, r2
 800030a:	4699      	mov	r9, r3
 800030c:	46a2      	mov	sl, r4
 800030e:	46ab      	mov	fp, r5
 8000310:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000312:	42a3      	cmp	r3, r4
 8000314:	d9d6      	bls.n	80002c4 <__udivmoddi4+0x50>
 8000316:	2200      	movs	r2, #0
 8000318:	2300      	movs	r3, #0
 800031a:	9200      	str	r2, [sp, #0]
 800031c:	9301      	str	r3, [sp, #4]
 800031e:	4643      	mov	r3, r8
 8000320:	2b00      	cmp	r3, #0
 8000322:	d0e8      	beq.n	80002f6 <__udivmoddi4+0x82>
 8000324:	07fb      	lsls	r3, r7, #31
 8000326:	0872      	lsrs	r2, r6, #1
 8000328:	431a      	orrs	r2, r3
 800032a:	4646      	mov	r6, r8
 800032c:	087b      	lsrs	r3, r7, #1
 800032e:	e00e      	b.n	800034e <__udivmoddi4+0xda>
 8000330:	42ab      	cmp	r3, r5
 8000332:	d101      	bne.n	8000338 <__udivmoddi4+0xc4>
 8000334:	42a2      	cmp	r2, r4
 8000336:	d80c      	bhi.n	8000352 <__udivmoddi4+0xde>
 8000338:	1aa4      	subs	r4, r4, r2
 800033a:	419d      	sbcs	r5, r3
 800033c:	2001      	movs	r0, #1
 800033e:	1924      	adds	r4, r4, r4
 8000340:	416d      	adcs	r5, r5
 8000342:	2100      	movs	r1, #0
 8000344:	3e01      	subs	r6, #1
 8000346:	1824      	adds	r4, r4, r0
 8000348:	414d      	adcs	r5, r1
 800034a:	2e00      	cmp	r6, #0
 800034c:	d006      	beq.n	800035c <__udivmoddi4+0xe8>
 800034e:	42ab      	cmp	r3, r5
 8000350:	d9ee      	bls.n	8000330 <__udivmoddi4+0xbc>
 8000352:	3e01      	subs	r6, #1
 8000354:	1924      	adds	r4, r4, r4
 8000356:	416d      	adcs	r5, r5
 8000358:	2e00      	cmp	r6, #0
 800035a:	d1f8      	bne.n	800034e <__udivmoddi4+0xda>
 800035c:	465b      	mov	r3, fp
 800035e:	9800      	ldr	r0, [sp, #0]
 8000360:	9901      	ldr	r1, [sp, #4]
 8000362:	1900      	adds	r0, r0, r4
 8000364:	4169      	adcs	r1, r5
 8000366:	2b00      	cmp	r3, #0
 8000368:	db22      	blt.n	80003b0 <__udivmoddi4+0x13c>
 800036a:	002b      	movs	r3, r5
 800036c:	465a      	mov	r2, fp
 800036e:	40d3      	lsrs	r3, r2
 8000370:	002a      	movs	r2, r5
 8000372:	4644      	mov	r4, r8
 8000374:	40e2      	lsrs	r2, r4
 8000376:	001c      	movs	r4, r3
 8000378:	465b      	mov	r3, fp
 800037a:	0015      	movs	r5, r2
 800037c:	2b00      	cmp	r3, #0
 800037e:	db2c      	blt.n	80003da <__udivmoddi4+0x166>
 8000380:	0026      	movs	r6, r4
 8000382:	409e      	lsls	r6, r3
 8000384:	0033      	movs	r3, r6
 8000386:	0026      	movs	r6, r4
 8000388:	4647      	mov	r7, r8
 800038a:	40be      	lsls	r6, r7
 800038c:	0032      	movs	r2, r6
 800038e:	1a80      	subs	r0, r0, r2
 8000390:	4199      	sbcs	r1, r3
 8000392:	9000      	str	r0, [sp, #0]
 8000394:	9101      	str	r1, [sp, #4]
 8000396:	e7ae      	b.n	80002f6 <__udivmoddi4+0x82>
 8000398:	4642      	mov	r2, r8
 800039a:	2320      	movs	r3, #32
 800039c:	1a9b      	subs	r3, r3, r2
 800039e:	4652      	mov	r2, sl
 80003a0:	40da      	lsrs	r2, r3
 80003a2:	4641      	mov	r1, r8
 80003a4:	0013      	movs	r3, r2
 80003a6:	464a      	mov	r2, r9
 80003a8:	408a      	lsls	r2, r1
 80003aa:	0017      	movs	r7, r2
 80003ac:	431f      	orrs	r7, r3
 80003ae:	e782      	b.n	80002b6 <__udivmoddi4+0x42>
 80003b0:	4642      	mov	r2, r8
 80003b2:	2320      	movs	r3, #32
 80003b4:	1a9b      	subs	r3, r3, r2
 80003b6:	002a      	movs	r2, r5
 80003b8:	4646      	mov	r6, r8
 80003ba:	409a      	lsls	r2, r3
 80003bc:	0023      	movs	r3, r4
 80003be:	40f3      	lsrs	r3, r6
 80003c0:	4313      	orrs	r3, r2
 80003c2:	e7d5      	b.n	8000370 <__udivmoddi4+0xfc>
 80003c4:	4642      	mov	r2, r8
 80003c6:	2320      	movs	r3, #32
 80003c8:	2100      	movs	r1, #0
 80003ca:	1a9b      	subs	r3, r3, r2
 80003cc:	2200      	movs	r2, #0
 80003ce:	9100      	str	r1, [sp, #0]
 80003d0:	9201      	str	r2, [sp, #4]
 80003d2:	2201      	movs	r2, #1
 80003d4:	40da      	lsrs	r2, r3
 80003d6:	9201      	str	r2, [sp, #4]
 80003d8:	e782      	b.n	80002e0 <__udivmoddi4+0x6c>
 80003da:	4642      	mov	r2, r8
 80003dc:	2320      	movs	r3, #32
 80003de:	0026      	movs	r6, r4
 80003e0:	1a9b      	subs	r3, r3, r2
 80003e2:	40de      	lsrs	r6, r3
 80003e4:	002f      	movs	r7, r5
 80003e6:	46b4      	mov	ip, r6
 80003e8:	4097      	lsls	r7, r2
 80003ea:	4666      	mov	r6, ip
 80003ec:	003b      	movs	r3, r7
 80003ee:	4333      	orrs	r3, r6
 80003f0:	e7c9      	b.n	8000386 <__udivmoddi4+0x112>
 80003f2:	46c0      	nop			; (mov r8, r8)

080003f4 <__clzdi2>:
 80003f4:	b510      	push	{r4, lr}
 80003f6:	2900      	cmp	r1, #0
 80003f8:	d103      	bne.n	8000402 <__clzdi2+0xe>
 80003fa:	f000 f807 	bl	800040c <__clzsi2>
 80003fe:	3020      	adds	r0, #32
 8000400:	e002      	b.n	8000408 <__clzdi2+0x14>
 8000402:	1c08      	adds	r0, r1, #0
 8000404:	f000 f802 	bl	800040c <__clzsi2>
 8000408:	bd10      	pop	{r4, pc}
 800040a:	46c0      	nop			; (mov r8, r8)

0800040c <__clzsi2>:
 800040c:	211c      	movs	r1, #28
 800040e:	2301      	movs	r3, #1
 8000410:	041b      	lsls	r3, r3, #16
 8000412:	4298      	cmp	r0, r3
 8000414:	d301      	bcc.n	800041a <__clzsi2+0xe>
 8000416:	0c00      	lsrs	r0, r0, #16
 8000418:	3910      	subs	r1, #16
 800041a:	0a1b      	lsrs	r3, r3, #8
 800041c:	4298      	cmp	r0, r3
 800041e:	d301      	bcc.n	8000424 <__clzsi2+0x18>
 8000420:	0a00      	lsrs	r0, r0, #8
 8000422:	3908      	subs	r1, #8
 8000424:	091b      	lsrs	r3, r3, #4
 8000426:	4298      	cmp	r0, r3
 8000428:	d301      	bcc.n	800042e <__clzsi2+0x22>
 800042a:	0900      	lsrs	r0, r0, #4
 800042c:	3904      	subs	r1, #4
 800042e:	a202      	add	r2, pc, #8	; (adr r2, 8000438 <__clzsi2+0x2c>)
 8000430:	5c10      	ldrb	r0, [r2, r0]
 8000432:	1840      	adds	r0, r0, r1
 8000434:	4770      	bx	lr
 8000436:	46c0      	nop			; (mov r8, r8)
 8000438:	02020304 	.word	0x02020304
 800043c:	01010101 	.word	0x01010101
	...

08000448 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000448:	21fa      	movs	r1, #250	; 0xfa
 800044a:	4b08      	ldr	r3, [pc, #32]	; (800046c <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800044c:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 800044e:	0089      	lsls	r1, r1, #2
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000450:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000452:	6818      	ldr	r0, [r3, #0]
 8000454:	f7ff fe62 	bl	800011c <__aeabi_uidiv>
 8000458:	f000 f86e 	bl	8000538 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 800045c:	2001      	movs	r0, #1
 800045e:	2200      	movs	r2, #0
 8000460:	0021      	movs	r1, r4
 8000462:	4240      	negs	r0, r0
 8000464:	f000 f82e 	bl	80004c4 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 8000468:	2000      	movs	r0, #0
 800046a:	bd10      	pop	{r4, pc}
 800046c:	20000000 	.word	0x20000000

08000470 <HAL_Init>:
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 8000470:	2140      	movs	r1, #64	; 0x40
 8000472:	4a06      	ldr	r2, [pc, #24]	; (800048c <HAL_Init+0x1c>)
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000474:	b510      	push	{r4, lr}
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 8000476:	6813      	ldr	r3, [r2, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 8000478:	2000      	movs	r0, #0
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 800047a:	430b      	orrs	r3, r1
 800047c:	6013      	str	r3, [r2, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 800047e:	f7ff ffe3 	bl	8000448 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000482:	f001 fb3f 	bl	8001b04 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000486:	2000      	movs	r0, #0
 8000488:	bd10      	pop	{r4, pc}
 800048a:	46c0      	nop			; (mov r8, r8)
 800048c:	40022000 	.word	0x40022000

08000490 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000490:	4a02      	ldr	r2, [pc, #8]	; (800049c <HAL_IncTick+0xc>)
 8000492:	6813      	ldr	r3, [r2, #0]
 8000494:	3301      	adds	r3, #1
 8000496:	6013      	str	r3, [r2, #0]
}
 8000498:	4770      	bx	lr
 800049a:	46c0      	nop			; (mov r8, r8)
 800049c:	20000020 	.word	0x20000020

080004a0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80004a0:	4b01      	ldr	r3, [pc, #4]	; (80004a8 <HAL_GetTick+0x8>)
 80004a2:	6818      	ldr	r0, [r3, #0]
}
 80004a4:	4770      	bx	lr
 80004a6:	46c0      	nop			; (mov r8, r8)
 80004a8:	20000020 	.word	0x20000020

080004ac <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80004ac:	b513      	push	{r0, r1, r4, lr}
 80004ae:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 80004b0:	f7ff fff6 	bl	80004a0 <HAL_GetTick>
 80004b4:	0004      	movs	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 80004b6:	f7ff fff3 	bl	80004a0 <HAL_GetTick>
 80004ba:	9b01      	ldr	r3, [sp, #4]
 80004bc:	1b00      	subs	r0, r0, r4
 80004be:	4298      	cmp	r0, r3
 80004c0:	d3f9      	bcc.n	80004b6 <HAL_Delay+0xa>
  {
  }
}
 80004c2:	bd13      	pop	{r0, r1, r4, pc}

080004c4 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80004c4:	b570      	push	{r4, r5, r6, lr}
 80004c6:	0189      	lsls	r1, r1, #6
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80004c8:	2800      	cmp	r0, #0
 80004ca:	da14      	bge.n	80004f6 <HAL_NVIC_SetPriority+0x32>
 80004cc:	230f      	movs	r3, #15
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80004ce:	b2c0      	uxtb	r0, r0
 80004d0:	4003      	ands	r3, r0
 80004d2:	3b08      	subs	r3, #8
 80004d4:	4a11      	ldr	r2, [pc, #68]	; (800051c <HAL_NVIC_SetPriority+0x58>)
 80004d6:	089b      	lsrs	r3, r3, #2
 80004d8:	2403      	movs	r4, #3
 80004da:	009b      	lsls	r3, r3, #2
 80004dc:	189b      	adds	r3, r3, r2
 80004de:	22ff      	movs	r2, #255	; 0xff
 80004e0:	4020      	ands	r0, r4
 80004e2:	40a0      	lsls	r0, r4
 80004e4:	0014      	movs	r4, r2
 80004e6:	400a      	ands	r2, r1
 80004e8:	4084      	lsls	r4, r0
 80004ea:	4082      	lsls	r2, r0
 80004ec:	69dd      	ldr	r5, [r3, #28]
 80004ee:	43a5      	bics	r5, r4
 80004f0:	432a      	orrs	r2, r5
 80004f2:	61da      	str	r2, [r3, #28]
 80004f4:	e011      	b.n	800051a <HAL_NVIC_SetPriority+0x56>
 80004f6:	0882      	lsrs	r2, r0, #2
 80004f8:	4b09      	ldr	r3, [pc, #36]	; (8000520 <HAL_NVIC_SetPriority+0x5c>)
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80004fa:	2503      	movs	r5, #3
 80004fc:	0092      	lsls	r2, r2, #2
 80004fe:	18d2      	adds	r2, r2, r3
 8000500:	23ff      	movs	r3, #255	; 0xff
 8000502:	4028      	ands	r0, r5
 8000504:	40a8      	lsls	r0, r5
 8000506:	001d      	movs	r5, r3
 8000508:	24c0      	movs	r4, #192	; 0xc0
 800050a:	4085      	lsls	r5, r0
 800050c:	400b      	ands	r3, r1
 800050e:	4083      	lsls	r3, r0
 8000510:	00a4      	lsls	r4, r4, #2
 8000512:	5916      	ldr	r6, [r2, r4]
 8000514:	43ae      	bics	r6, r5
 8000516:	4333      	orrs	r3, r6
 8000518:	5113      	str	r3, [r2, r4]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 800051a:	bd70      	pop	{r4, r5, r6, pc}
 800051c:	e000ed00 	.word	0xe000ed00
 8000520:	e000e100 	.word	0xe000e100

08000524 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000524:	231f      	movs	r3, #31
 8000526:	4018      	ands	r0, r3
 8000528:	3b1e      	subs	r3, #30
 800052a:	4083      	lsls	r3, r0
 800052c:	4a01      	ldr	r2, [pc, #4]	; (8000534 <HAL_NVIC_EnableIRQ+0x10>)
 800052e:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000530:	4770      	bx	lr
 8000532:	46c0      	nop			; (mov r8, r8)
 8000534:	e000e100 	.word	0xe000e100

08000538 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000538:	4a09      	ldr	r2, [pc, #36]	; (8000560 <HAL_SYSTICK_Config+0x28>)
 800053a:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 800053c:	2001      	movs	r0, #1
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800053e:	4293      	cmp	r3, r2
 8000540:	d80d      	bhi.n	800055e <HAL_SYSTICK_Config+0x26>
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000542:	20c0      	movs	r0, #192	; 0xc0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000544:	4a07      	ldr	r2, [pc, #28]	; (8000564 <HAL_SYSTICK_Config+0x2c>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000546:	4908      	ldr	r1, [pc, #32]	; (8000568 <HAL_SYSTICK_Config+0x30>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000548:	6053      	str	r3, [r2, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800054a:	6a0b      	ldr	r3, [r1, #32]
 800054c:	0600      	lsls	r0, r0, #24
 800054e:	021b      	lsls	r3, r3, #8
 8000550:	0a1b      	lsrs	r3, r3, #8
 8000552:	4303      	orrs	r3, r0
 8000554:	620b      	str	r3, [r1, #32]
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000556:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000558:	2307      	movs	r3, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800055a:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800055c:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 800055e:	4770      	bx	lr
 8000560:	00ffffff 	.word	0x00ffffff
 8000564:	e000e010 	.word	0xe000e010
 8000568:	e000ed00 	.word	0xe000ed00

0800056c <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 800056c:	4b05      	ldr	r3, [pc, #20]	; (8000584 <HAL_SYSTICK_CLKSourceConfig+0x18>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800056e:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000570:	2804      	cmp	r0, #4
 8000572:	d102      	bne.n	800057a <HAL_SYSTICK_CLKSourceConfig+0xe>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000574:	4310      	orrs	r0, r2
 8000576:	6018      	str	r0, [r3, #0]
 8000578:	e002      	b.n	8000580 <HAL_SYSTICK_CLKSourceConfig+0x14>
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800057a:	2104      	movs	r1, #4
 800057c:	438a      	bics	r2, r1
 800057e:	601a      	str	r2, [r3, #0]
  }
}
 8000580:	4770      	bx	lr
 8000582:	46c0      	nop			; (mov r8, r8)
 8000584:	e000e010 	.word	0xe000e010

08000588 <HAL_SYSTICK_Callback>:
__weak void HAL_SYSTICK_Callback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 8000588:	4770      	bx	lr

0800058a <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 800058a:	b510      	push	{r4, lr}
  HAL_SYSTICK_Callback();
 800058c:	f7ff fffc 	bl	8000588 <HAL_SYSTICK_Callback>
}
 8000590:	bd10      	pop	{r4, pc}
	...

08000594 <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{  
 8000594:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status = HAL_OK;
  
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8000596:	1d84      	adds	r4, r0, #6
 8000598:	7fe3      	ldrb	r3, [r4, #31]
 800059a:	2b02      	cmp	r3, #2
 800059c:	d003      	beq.n	80005a6 <HAL_DMA_Abort_IT+0x12>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800059e:	2304      	movs	r3, #4
 80005a0:	63c3      	str	r3, [r0, #60]	; 0x3c
        
    status = HAL_ERROR;
 80005a2:	3b03      	subs	r3, #3
 80005a4:	e036      	b.n	8000614 <HAL_DMA_Abort_IT+0x80>
  }
  else
  { 
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80005a6:	210e      	movs	r1, #14
 80005a8:	6802      	ldr	r2, [r0, #0]
 80005aa:	6813      	ldr	r3, [r2, #0]
 80005ac:	438b      	bics	r3, r1
 80005ae:	6013      	str	r3, [r2, #0]
    
    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 80005b0:	2301      	movs	r3, #1
 80005b2:	6811      	ldr	r1, [r2, #0]
 80005b4:	4399      	bics	r1, r3
 80005b6:	6011      	str	r1, [r2, #0]
    
    /* Clear all flags */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 80005b8:	4917      	ldr	r1, [pc, #92]	; (8000618 <HAL_DMA_Abort_IT+0x84>)
 80005ba:	428a      	cmp	r2, r1
 80005bc:	d01d      	beq.n	80005fa <HAL_DMA_Abort_IT+0x66>
 80005be:	4917      	ldr	r1, [pc, #92]	; (800061c <HAL_DMA_Abort_IT+0x88>)
 80005c0:	330f      	adds	r3, #15
 80005c2:	428a      	cmp	r2, r1
 80005c4:	d019      	beq.n	80005fa <HAL_DMA_Abort_IT+0x66>
 80005c6:	4b16      	ldr	r3, [pc, #88]	; (8000620 <HAL_DMA_Abort_IT+0x8c>)
 80005c8:	429a      	cmp	r2, r3
 80005ca:	d00b      	beq.n	80005e4 <HAL_DMA_Abort_IT+0x50>
 80005cc:	4b15      	ldr	r3, [pc, #84]	; (8000624 <HAL_DMA_Abort_IT+0x90>)
 80005ce:	429a      	cmp	r2, r3
 80005d0:	d00b      	beq.n	80005ea <HAL_DMA_Abort_IT+0x56>
 80005d2:	4b15      	ldr	r3, [pc, #84]	; (8000628 <HAL_DMA_Abort_IT+0x94>)
 80005d4:	429a      	cmp	r2, r3
 80005d6:	d00b      	beq.n	80005f0 <HAL_DMA_Abort_IT+0x5c>
 80005d8:	4b14      	ldr	r3, [pc, #80]	; (800062c <HAL_DMA_Abort_IT+0x98>)
 80005da:	429a      	cmp	r2, r3
 80005dc:	d00b      	beq.n	80005f6 <HAL_DMA_Abort_IT+0x62>
 80005de:	2380      	movs	r3, #128	; 0x80
 80005e0:	045b      	lsls	r3, r3, #17
 80005e2:	e00a      	b.n	80005fa <HAL_DMA_Abort_IT+0x66>
 80005e4:	2380      	movs	r3, #128	; 0x80
 80005e6:	005b      	lsls	r3, r3, #1
 80005e8:	e007      	b.n	80005fa <HAL_DMA_Abort_IT+0x66>
 80005ea:	2380      	movs	r3, #128	; 0x80
 80005ec:	015b      	lsls	r3, r3, #5
 80005ee:	e004      	b.n	80005fa <HAL_DMA_Abort_IT+0x66>
 80005f0:	2380      	movs	r3, #128	; 0x80
 80005f2:	025b      	lsls	r3, r3, #9
 80005f4:	e001      	b.n	80005fa <HAL_DMA_Abort_IT+0x66>
 80005f6:	2380      	movs	r3, #128	; 0x80
 80005f8:	035b      	lsls	r3, r3, #13
 80005fa:	4a0d      	ldr	r2, [pc, #52]	; (8000630 <HAL_DMA_Abort_IT+0x9c>)
 80005fc:	6053      	str	r3, [r2, #4]
    
    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80005fe:	2301      	movs	r3, #1
 8000600:	77e3      	strb	r3, [r4, #31]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8000602:	2400      	movs	r4, #0
    
    /* Call User Abort callback */ 
    if(hdma->XferAbortCallback != NULL)
 8000604:	6b82      	ldr	r2, [r0, #56]	; 0x38
    
    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8000606:	1d43      	adds	r3, r0, #5
 8000608:	77dc      	strb	r4, [r3, #31]
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{  
  HAL_StatusTypeDef status = HAL_OK;
 800060a:	1e13      	subs	r3, r2, #0
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
    
    /* Call User Abort callback */ 
    if(hdma->XferAbortCallback != NULL)
 800060c:	42a3      	cmp	r3, r4
 800060e:	d001      	beq.n	8000614 <HAL_DMA_Abort_IT+0x80>
    {
      hdma->XferAbortCallback(hdma);
 8000610:	4790      	blx	r2
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{  
  HAL_StatusTypeDef status = HAL_OK;
 8000612:	0023      	movs	r3, r4
    {
      hdma->XferAbortCallback(hdma);
    } 
  }
  return status;
}
 8000614:	0018      	movs	r0, r3
 8000616:	bd10      	pop	{r4, pc}
 8000618:	40020008 	.word	0x40020008
 800061c:	4002001c 	.word	0x4002001c
 8000620:	40020030 	.word	0x40020030
 8000624:	40020044 	.word	0x40020044
 8000628:	40020058 	.word	0x40020058
 800062c:	4002006c 	.word	0x4002006c
 8000630:	40020000 	.word	0x40020000

08000634 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000634:	b5f0      	push	{r4, r5, r6, r7, lr}
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8000636:	4a55      	ldr	r2, [pc, #340]	; (800078c <HAL_GPIO_Init+0x158>)
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 8000638:	680b      	ldr	r3, [r1, #0]
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 800063a:	1882      	adds	r2, r0, r2
 800063c:	1e54      	subs	r4, r2, #1
 800063e:	41a2      	sbcs	r2, r4
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000640:	b085      	sub	sp, #20
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 8000642:	9301      	str	r3, [sp, #4]
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00U;
 8000644:	2300      	movs	r3, #0
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8000646:	3205      	adds	r2, #5
 8000648:	9203      	str	r2, [sp, #12]
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800064a:	9a01      	ldr	r2, [sp, #4]
 800064c:	40da      	lsrs	r2, r3
 800064e:	d100      	bne.n	8000652 <HAL_GPIO_Init+0x1e>
 8000650:	e09a      	b.n	8000788 <HAL_GPIO_Init+0x154>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000652:	2601      	movs	r6, #1
 8000654:	409e      	lsls	r6, r3
 8000656:	9a01      	ldr	r2, [sp, #4]
 8000658:	4032      	ands	r2, r6
 800065a:	9200      	str	r2, [sp, #0]
    
    if(iocurrent)
 800065c:	d100      	bne.n	8000660 <HAL_GPIO_Init+0x2c>
 800065e:	e091      	b.n	8000784 <HAL_GPIO_Init+0x150>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8000660:	684a      	ldr	r2, [r1, #4]
 8000662:	4694      	mov	ip, r2
 8000664:	2210      	movs	r2, #16
 8000666:	4664      	mov	r4, ip
 8000668:	4394      	bics	r4, r2
 800066a:	0022      	movs	r2, r4
 800066c:	3c01      	subs	r4, #1
 800066e:	2a02      	cmp	r2, #2
 8000670:	d10e      	bne.n	8000690 <HAL_GPIO_Init+0x5c>
      {
        /* Check if the Alternate function is compliant with the GPIO in use */
        assert_param(IS_GPIO_AF_AVAILABLE(GPIOx,(GPIO_Init->Alternate)));
        /* Configure Alternate function mapped with the current IO */ 
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8000672:	2407      	movs	r4, #7
 8000674:	270f      	movs	r7, #15
 8000676:	401c      	ands	r4, r3
 8000678:	00a4      	lsls	r4, r4, #2
 800067a:	40a7      	lsls	r7, r4
 800067c:	08da      	lsrs	r2, r3, #3
 800067e:	0092      	lsls	r2, r2, #2
 8000680:	1882      	adds	r2, r0, r2
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
      {
        /* Check if the Alternate function is compliant with the GPIO in use */
        assert_param(IS_GPIO_AF_AVAILABLE(GPIOx,(GPIO_Init->Alternate)));
        /* Configure Alternate function mapped with the current IO */ 
        temp = GPIOx->AFR[position >> 3U];
 8000682:	6a15      	ldr	r5, [r2, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8000684:	43bd      	bics	r5, r7
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U)) ;
 8000686:	690f      	ldr	r7, [r1, #16]
 8000688:	40a7      	lsls	r7, r4
 800068a:	433d      	orrs	r5, r7
        GPIOx->AFR[position >> 3U] = temp;
 800068c:	6215      	str	r5, [r2, #32]
 800068e:	e001      	b.n	8000694 <HAL_GPIO_Init+0x60>
      } 

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000690:	2c01      	cmp	r4, #1
 8000692:	d810      	bhi.n	80006b6 <HAL_GPIO_Init+0x82>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 8000694:	2403      	movs	r4, #3
 8000696:	005d      	lsls	r5, r3, #1
 8000698:	40ac      	lsls	r4, r5
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800069a:	6882      	ldr	r2, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 800069c:	43a2      	bics	r2, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 800069e:	68cc      	ldr	r4, [r1, #12]
 80006a0:	40ac      	lsls	r4, r5
 80006a2:	4322      	orrs	r2, r4
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp= GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80006a4:	4664      	mov	r4, ip
 80006a6:	06e4      	lsls	r4, r4, #27
 80006a8:	0fe4      	lsrs	r4, r4, #31
 80006aa:	409c      	lsls	r4, r3
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;
 80006ac:	6082      	str	r2, [r0, #8]

        /* Configure the IO Output Type */
        temp= GPIOx->OTYPER;
 80006ae:	6842      	ldr	r2, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80006b0:	43b2      	bics	r2, r6
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80006b2:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 80006b4:	6042      	str	r2, [r0, #4]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80006b6:	2603      	movs	r6, #3
 80006b8:	0034      	movs	r4, r6
 80006ba:	005d      	lsls	r5, r3, #1
 80006bc:	40ac      	lsls	r4, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80006be:	4667      	mov	r7, ip
        GPIOx->OTYPER = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80006c0:	43e4      	mvns	r4, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80006c2:	4037      	ands	r7, r6
 80006c4:	40af      	lsls	r7, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
        GPIOx->OTYPER = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80006c6:	6802      	ldr	r2, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80006c8:	4022      	ands	r2, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80006ca:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;
 80006cc:	6002      	str	r2, [r0, #0]

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80006ce:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80006d0:	4014      	ands	r4, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U)); 
 80006d2:	688a      	ldr	r2, [r1, #8]
 80006d4:	40aa      	lsls	r2, r5
 80006d6:	4314      	orrs	r4, r2
      GPIOx->PUPDR = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80006d8:	4662      	mov	r2, ip

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
      temp |= ((GPIO_Init->Pull) << (position * 2U)); 
      GPIOx->PUPDR = temp;
 80006da:	60c4      	str	r4, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80006dc:	00d2      	lsls	r2, r2, #3
 80006de:	d551      	bpl.n	8000784 <HAL_GPIO_Init+0x150>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006e0:	2501      	movs	r5, #1
 80006e2:	4c2b      	ldr	r4, [pc, #172]	; (8000790 <HAL_GPIO_Init+0x15c>)
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80006e4:	270f      	movs	r7, #15
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006e6:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80006e8:	432a      	orrs	r2, r5
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80006ea:	001d      	movs	r5, r3
 80006ec:	4035      	ands	r5, r6
 80006ee:	00ad      	lsls	r5, r5, #2
 80006f0:	40af      	lsls	r7, r5
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80006f2:	6362      	str	r2, [r4, #52]	; 0x34
 80006f4:	4a27      	ldr	r2, [pc, #156]	; (8000794 <HAL_GPIO_Init+0x160>)
 80006f6:	089c      	lsrs	r4, r3, #2
 80006f8:	00a4      	lsls	r4, r4, #2
 80006fa:	18a4      	adds	r4, r4, r2
        
        temp = SYSCFG->EXTICR[position >> 2U];
 80006fc:	68a2      	ldr	r2, [r4, #8]
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80006fe:	43ba      	bics	r2, r7
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8000700:	27a0      	movs	r7, #160	; 0xa0
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000702:	9202      	str	r2, [sp, #8]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8000704:	05ff      	lsls	r7, r7, #23
 8000706:	2200      	movs	r2, #0
 8000708:	42b8      	cmp	r0, r7
 800070a:	d010      	beq.n	800072e <HAL_GPIO_Init+0xfa>
 800070c:	4f22      	ldr	r7, [pc, #136]	; (8000798 <HAL_GPIO_Init+0x164>)
 800070e:	3201      	adds	r2, #1
 8000710:	42b8      	cmp	r0, r7
 8000712:	d00c      	beq.n	800072e <HAL_GPIO_Init+0xfa>
 8000714:	4f21      	ldr	r7, [pc, #132]	; (800079c <HAL_GPIO_Init+0x168>)
 8000716:	3201      	adds	r2, #1
 8000718:	42b8      	cmp	r0, r7
 800071a:	d008      	beq.n	800072e <HAL_GPIO_Init+0xfa>
 800071c:	0032      	movs	r2, r6
 800071e:	4e20      	ldr	r6, [pc, #128]	; (80007a0 <HAL_GPIO_Init+0x16c>)
 8000720:	42b0      	cmp	r0, r6
 8000722:	d004      	beq.n	800072e <HAL_GPIO_Init+0xfa>
 8000724:	4e1f      	ldr	r6, [pc, #124]	; (80007a4 <HAL_GPIO_Init+0x170>)
 8000726:	3201      	adds	r2, #1
 8000728:	42b0      	cmp	r0, r6
 800072a:	d000      	beq.n	800072e <HAL_GPIO_Init+0xfa>
 800072c:	9a03      	ldr	r2, [sp, #12]
 800072e:	40aa      	lsls	r2, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000730:	4667      	mov	r7, ip
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2U];
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8000732:	9d02      	ldr	r5, [sp, #8]
 8000734:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000736:	60a2      	str	r2, [r4, #8]
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000738:	4a1b      	ldr	r2, [pc, #108]	; (80007a8 <HAL_GPIO_Init+0x174>)
        temp &= ~((uint32_t)iocurrent);
 800073a:	9c00      	ldr	r4, [sp, #0]
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800073c:	6816      	ldr	r6, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 800073e:	9d00      	ldr	r5, [sp, #0]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8000740:	43e4      	mvns	r4, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8000742:	4335      	orrs	r5, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000744:	03ff      	lsls	r7, r7, #15
 8000746:	d401      	bmi.n	800074c <HAL_GPIO_Init+0x118>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8000748:	0035      	movs	r5, r6
 800074a:	4025      	ands	r5, r4
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800074c:	4667      	mov	r7, ip
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 800074e:	6015      	str	r5, [r2, #0]

        temp = EXTI->EMR;
 8000750:	6856      	ldr	r6, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8000752:	9d00      	ldr	r5, [sp, #0]
 8000754:	4335      	orrs	r5, r6
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000756:	03bf      	lsls	r7, r7, #14
 8000758:	d401      	bmi.n	800075e <HAL_GPIO_Init+0x12a>
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 800075a:	0035      	movs	r5, r6
 800075c:	4025      	ands	r5, r4
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800075e:	4667      	mov	r7, ip
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 8000760:	6055      	str	r5, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000762:	6896      	ldr	r6, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8000764:	9d00      	ldr	r5, [sp, #0]
 8000766:	4335      	orrs	r5, r6
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000768:	02ff      	lsls	r7, r7, #11
 800076a:	d401      	bmi.n	8000770 <HAL_GPIO_Init+0x13c>
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 800076c:	0035      	movs	r5, r6
 800076e:	4025      	ands	r5, r4
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000770:	4667      	mov	r7, ip
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8000772:	6095      	str	r5, [r2, #8]

        temp = EXTI->FTSR;
 8000774:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000776:	9e00      	ldr	r6, [sp, #0]
 8000778:	432e      	orrs	r6, r5
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800077a:	02bf      	lsls	r7, r7, #10
 800077c:	d401      	bmi.n	8000782 <HAL_GPIO_Init+0x14e>
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 800077e:	4025      	ands	r5, r4
 8000780:	002e      	movs	r6, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
 8000782:	60d6      	str	r6, [r2, #12]
      }
    }
    position++;
 8000784:	3301      	adds	r3, #1
 8000786:	e760      	b.n	800064a <HAL_GPIO_Init+0x16>
  }
}
 8000788:	b005      	add	sp, #20
 800078a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800078c:	afffe400 	.word	0xafffe400
 8000790:	40021000 	.word	0x40021000
 8000794:	40010000 	.word	0x40010000
 8000798:	50000400 	.word	0x50000400
 800079c:	50000800 	.word	0x50000800
 80007a0:	50000c00 	.word	0x50000c00
 80007a4:	50001000 	.word	0x50001000
 80007a8:	40010400 	.word	0x40010400

080007ac <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));
  
  if(PinState != GPIO_PIN_RESET)
 80007ac:	2a00      	cmp	r2, #0
 80007ae:	d001      	beq.n	80007b4 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = GPIO_Pin;
 80007b0:	6181      	str	r1, [r0, #24]
 80007b2:	e000      	b.n	80007b6 <HAL_GPIO_WritePin+0xa>
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
 80007b4:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 80007b6:	4770      	bx	lr

080007b8 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80007b8:	6943      	ldr	r3, [r0, #20]
 80007ba:	4059      	eors	r1, r3
 80007bc:	6141      	str	r1, [r0, #20]
}
 80007be:	4770      	bx	lr

080007c0 <RCC_SetFlashLatencyFromMSIRange>:
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 80007c0:	22f0      	movs	r2, #240	; 0xf0
 80007c2:	4b16      	ldr	r3, [pc, #88]	; (800081c <RCC_SetFlashLatencyFromMSIRange+0x5c>)
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 80007c4:	b530      	push	{r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 80007c6:	68d9      	ldr	r1, [r3, #12]
 80007c8:	4211      	tst	r1, r2
 80007ca:	d001      	beq.n	80007d0 <RCC_SetFlashLatencyFromMSIRange+0x10>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80007cc:	2300      	movs	r3, #0
 80007ce:	e01b      	b.n	8000808 <RCC_SetFlashLatencyFromMSIRange+0x48>

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
  {
    if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80007d0:	2580      	movs	r5, #128	; 0x80
 80007d2:	22c0      	movs	r2, #192	; 0xc0
 80007d4:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80007d6:	056d      	lsls	r5, r5, #21
 80007d8:	4c11      	ldr	r4, [pc, #68]	; (8000820 <RCC_SetFlashLatencyFromMSIRange+0x60>)
 80007da:	0152      	lsls	r2, r2, #5
 80007dc:	4229      	tst	r1, r5
 80007de:	d002      	beq.n	80007e6 <RCC_SetFlashLatencyFromMSIRange+0x26>
    {
      vos = READ_BIT(PWR->CR, PWR_CR_VOS);
 80007e0:	6823      	ldr	r3, [r4, #0]
 80007e2:	401a      	ands	r2, r3
 80007e4:	e008      	b.n	80007f8 <RCC_SetFlashLatencyFromMSIRange+0x38>
    }
    else
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80007e6:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80007e8:	4329      	orrs	r1, r5
 80007ea:	6399      	str	r1, [r3, #56]	; 0x38
      vos = READ_BIT(PWR->CR, PWR_CR_VOS);
 80007ec:	6821      	ldr	r1, [r4, #0]
      __HAL_RCC_PWR_CLK_DISABLE();
 80007ee:	6b9c      	ldr	r4, [r3, #56]	; 0x38
      vos = READ_BIT(PWR->CR, PWR_CR_VOS);
    }
    else
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      vos = READ_BIT(PWR->CR, PWR_CR_VOS);
 80007f0:	400a      	ands	r2, r1
      __HAL_RCC_PWR_CLK_DISABLE();
 80007f2:	490c      	ldr	r1, [pc, #48]	; (8000824 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 80007f4:	4021      	ands	r1, r4
 80007f6:	6399      	str	r1, [r3, #56]	; 0x38
    }
    
    /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
    if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (MSIrange == RCC_MSIRANGE_6))
 80007f8:	23c0      	movs	r3, #192	; 0xc0
 80007fa:	015b      	lsls	r3, r3, #5
 80007fc:	429a      	cmp	r2, r3
 80007fe:	d1e5      	bne.n	80007cc <RCC_SetFlashLatencyFromMSIRange+0xc>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8000800:	4b09      	ldr	r3, [pc, #36]	; (8000828 <RCC_SetFlashLatencyFromMSIRange+0x68>)
 8000802:	18c0      	adds	r0, r0, r3
 8000804:	4243      	negs	r3, r0
 8000806:	4143      	adcs	r3, r0
    {
      latency = FLASH_LATENCY_1; /* 1WS */
    }
  }
  
  __HAL_FLASH_SET_LATENCY(latency);
 8000808:	2001      	movs	r0, #1
 800080a:	4908      	ldr	r1, [pc, #32]	; (800082c <RCC_SetFlashLatencyFromMSIRange+0x6c>)
 800080c:	680a      	ldr	r2, [r1, #0]
 800080e:	4382      	bics	r2, r0
 8000810:	431a      	orrs	r2, r3
 8000812:	600a      	str	r2, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8000814:	680a      	ldr	r2, [r1, #0]
 8000816:	4010      	ands	r0, r2
 8000818:	4058      	eors	r0, r3
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 800081a:	bd30      	pop	{r4, r5, pc}
 800081c:	40021000 	.word	0x40021000
 8000820:	40007000 	.word	0x40007000
 8000824:	efffffff 	.word	0xefffffff
 8000828:	ffff4000 	.word	0xffff4000
 800082c:	40022000 	.word	0x40022000

08000830 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000830:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000832:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000834:	b085      	sub	sp, #20
 8000836:	0004      	movs	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000838:	07db      	lsls	r3, r3, #31
 800083a:	d403      	bmi.n	8000844 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800083c:	6823      	ldr	r3, [r4, #0]
 800083e:	079b      	lsls	r3, r3, #30
 8000840:	d457      	bmi.n	80008f2 <HAL_RCC_OscConfig+0xc2>
 8000842:	e0a0      	b.n	8000986 <HAL_RCC_OscConfig+0x156>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000844:	230c      	movs	r3, #12
 8000846:	4dc6      	ldr	r5, [pc, #792]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 8000848:	68ea      	ldr	r2, [r5, #12]
 800084a:	401a      	ands	r2, r3
 800084c:	2a08      	cmp	r2, #8
 800084e:	d008      	beq.n	8000862 <HAL_RCC_OscConfig+0x32>
 8000850:	2180      	movs	r1, #128	; 0x80
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000852:	68ea      	ldr	r2, [r5, #12]
 8000854:	0249      	lsls	r1, r1, #9
 8000856:	4013      	ands	r3, r2
 8000858:	2b0c      	cmp	r3, #12
 800085a:	d10a      	bne.n	8000872 <HAL_RCC_OscConfig+0x42>
 800085c:	68eb      	ldr	r3, [r5, #12]
 800085e:	420b      	tst	r3, r1
 8000860:	d007      	beq.n	8000872 <HAL_RCC_OscConfig+0x42>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000862:	682b      	ldr	r3, [r5, #0]
 8000864:	039b      	lsls	r3, r3, #14
 8000866:	d5e9      	bpl.n	800083c <HAL_RCC_OscConfig+0xc>
 8000868:	6863      	ldr	r3, [r4, #4]
 800086a:	2b00      	cmp	r3, #0
 800086c:	d1e6      	bne.n	800083c <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 800086e:	2001      	movs	r0, #1
 8000870:	e243      	b.n	8000cfa <HAL_RCC_OscConfig+0x4ca>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000872:	2380      	movs	r3, #128	; 0x80
 8000874:	6862      	ldr	r2, [r4, #4]
 8000876:	025b      	lsls	r3, r3, #9
 8000878:	428a      	cmp	r2, r1
 800087a:	d102      	bne.n	8000882 <HAL_RCC_OscConfig+0x52>
 800087c:	682b      	ldr	r3, [r5, #0]
 800087e:	430b      	orrs	r3, r1
 8000880:	e00a      	b.n	8000898 <HAL_RCC_OscConfig+0x68>
 8000882:	21a0      	movs	r1, #160	; 0xa0
 8000884:	02c9      	lsls	r1, r1, #11
 8000886:	428a      	cmp	r2, r1
 8000888:	d108      	bne.n	800089c <HAL_RCC_OscConfig+0x6c>
 800088a:	2180      	movs	r1, #128	; 0x80
 800088c:	682a      	ldr	r2, [r5, #0]
 800088e:	02c9      	lsls	r1, r1, #11
 8000890:	430a      	orrs	r2, r1
 8000892:	602a      	str	r2, [r5, #0]
 8000894:	682a      	ldr	r2, [r5, #0]
 8000896:	4313      	orrs	r3, r2
 8000898:	602b      	str	r3, [r5, #0]
 800089a:	e00d      	b.n	80008b8 <HAL_RCC_OscConfig+0x88>
 800089c:	6828      	ldr	r0, [r5, #0]
 800089e:	49b1      	ldr	r1, [pc, #708]	; (8000b64 <HAL_RCC_OscConfig+0x334>)
 80008a0:	4001      	ands	r1, r0
 80008a2:	6029      	str	r1, [r5, #0]
 80008a4:	6829      	ldr	r1, [r5, #0]
 80008a6:	400b      	ands	r3, r1
 80008a8:	9303      	str	r3, [sp, #12]
 80008aa:	9b03      	ldr	r3, [sp, #12]
 80008ac:	6829      	ldr	r1, [r5, #0]
 80008ae:	4bae      	ldr	r3, [pc, #696]	; (8000b68 <HAL_RCC_OscConfig+0x338>)
 80008b0:	400b      	ands	r3, r1
 80008b2:	602b      	str	r3, [r5, #0]
      

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80008b4:	2a00      	cmp	r2, #0
 80008b6:	d00e      	beq.n	80008d6 <HAL_RCC_OscConfig+0xa6>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80008b8:	f7ff fdf2 	bl	80004a0 <HAL_GetTick>
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80008bc:	2680      	movs	r6, #128	; 0x80

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80008be:	0007      	movs	r7, r0
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80008c0:	02b6      	lsls	r6, r6, #10
 80008c2:	682b      	ldr	r3, [r5, #0]
 80008c4:	4233      	tst	r3, r6
 80008c6:	d1b9      	bne.n	800083c <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80008c8:	f7ff fdea 	bl	80004a0 <HAL_GetTick>
 80008cc:	1bc0      	subs	r0, r0, r7
 80008ce:	2864      	cmp	r0, #100	; 0x64
 80008d0:	d9f7      	bls.n	80008c2 <HAL_RCC_OscConfig+0x92>
          {
            return HAL_TIMEOUT;
 80008d2:	2003      	movs	r0, #3
 80008d4:	e211      	b.n	8000cfa <HAL_RCC_OscConfig+0x4ca>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80008d6:	f7ff fde3 	bl	80004a0 <HAL_GetTick>
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80008da:	2680      	movs	r6, #128	; 0x80
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80008dc:	0007      	movs	r7, r0
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80008de:	02b6      	lsls	r6, r6, #10
 80008e0:	682b      	ldr	r3, [r5, #0]
 80008e2:	4233      	tst	r3, r6
 80008e4:	d0aa      	beq.n	800083c <HAL_RCC_OscConfig+0xc>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80008e6:	f7ff fddb 	bl	80004a0 <HAL_GetTick>
 80008ea:	1bc0      	subs	r0, r0, r7
 80008ec:	2864      	cmp	r0, #100	; 0x64
 80008ee:	d9f7      	bls.n	80008e0 <HAL_RCC_OscConfig+0xb0>
 80008f0:	e7ef      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80008f2:	230c      	movs	r3, #12
 80008f4:	4d9a      	ldr	r5, [pc, #616]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 80008f6:	68ea      	ldr	r2, [r5, #12]
 80008f8:	401a      	ands	r2, r3
 80008fa:	2a04      	cmp	r2, #4
 80008fc:	d006      	beq.n	800090c <HAL_RCC_OscConfig+0xdc>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80008fe:	68ea      	ldr	r2, [r5, #12]
 8000900:	4013      	ands	r3, r2
 8000902:	2b0c      	cmp	r3, #12
 8000904:	d110      	bne.n	8000928 <HAL_RCC_OscConfig+0xf8>
 8000906:	68eb      	ldr	r3, [r5, #12]
 8000908:	03db      	lsls	r3, r3, #15
 800090a:	d40d      	bmi.n	8000928 <HAL_RCC_OscConfig+0xf8>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800090c:	682b      	ldr	r3, [r5, #0]
 800090e:	075b      	lsls	r3, r3, #29
 8000910:	d502      	bpl.n	8000918 <HAL_RCC_OscConfig+0xe8>
 8000912:	68e3      	ldr	r3, [r4, #12]
 8000914:	2b01      	cmp	r3, #1
 8000916:	d1aa      	bne.n	800086e <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000918:	6922      	ldr	r2, [r4, #16]
 800091a:	686b      	ldr	r3, [r5, #4]
 800091c:	0211      	lsls	r1, r2, #8
 800091e:	4a93      	ldr	r2, [pc, #588]	; (8000b6c <HAL_RCC_OscConfig+0x33c>)
 8000920:	4013      	ands	r3, r2
 8000922:	430b      	orrs	r3, r1
 8000924:	606b      	str	r3, [r5, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000926:	e02e      	b.n	8000986 <HAL_RCC_OscConfig+0x156>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000928:	68e3      	ldr	r3, [r4, #12]
 800092a:	2b00      	cmp	r3, #0
 800092c:	d01a      	beq.n	8000964 <HAL_RCC_OscConfig+0x134>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800092e:	2109      	movs	r1, #9
 8000930:	682a      	ldr	r2, [r5, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000932:	2604      	movs	r6, #4
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8000934:	438a      	bics	r2, r1
 8000936:	4313      	orrs	r3, r2
 8000938:	602b      	str	r3, [r5, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800093a:	f7ff fdb1 	bl	80004a0 <HAL_GetTick>
 800093e:	0007      	movs	r7, r0
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000940:	682b      	ldr	r3, [r5, #0]
 8000942:	4887      	ldr	r0, [pc, #540]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 8000944:	4233      	tst	r3, r6
 8000946:	d105      	bne.n	8000954 <HAL_RCC_OscConfig+0x124>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000948:	f7ff fdaa 	bl	80004a0 <HAL_GetTick>
 800094c:	1bc0      	subs	r0, r0, r7
 800094e:	2802      	cmp	r0, #2
 8000950:	d9f6      	bls.n	8000940 <HAL_RCC_OscConfig+0x110>
 8000952:	e7be      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000954:	6922      	ldr	r2, [r4, #16]
 8000956:	6843      	ldr	r3, [r0, #4]
 8000958:	0211      	lsls	r1, r2, #8
 800095a:	4a84      	ldr	r2, [pc, #528]	; (8000b6c <HAL_RCC_OscConfig+0x33c>)
 800095c:	4013      	ands	r3, r2
 800095e:	430b      	orrs	r3, r1
 8000960:	6043      	str	r3, [r0, #4]
 8000962:	e010      	b.n	8000986 <HAL_RCC_OscConfig+0x156>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000964:	2201      	movs	r2, #1
 8000966:	682b      	ldr	r3, [r5, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000968:	2604      	movs	r6, #4
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800096a:	4393      	bics	r3, r2
 800096c:	602b      	str	r3, [r5, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800096e:	f7ff fd97 	bl	80004a0 <HAL_GetTick>
 8000972:	0007      	movs	r7, r0
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000974:	682b      	ldr	r3, [r5, #0]
 8000976:	4233      	tst	r3, r6
 8000978:	d005      	beq.n	8000986 <HAL_RCC_OscConfig+0x156>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800097a:	f7ff fd91 	bl	80004a0 <HAL_GetTick>
 800097e:	1bc0      	subs	r0, r0, r7
 8000980:	2802      	cmp	r0, #2
 8000982:	d9f7      	bls.n	8000974 <HAL_RCC_OscConfig+0x144>
 8000984:	e7a5      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8000986:	6823      	ldr	r3, [r4, #0]
 8000988:	06db      	lsls	r3, r3, #27
 800098a:	d400      	bmi.n	800098e <HAL_RCC_OscConfig+0x15e>
 800098c:	e080      	b.n	8000a90 <HAL_RCC_OscConfig+0x260>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 800098e:	230c      	movs	r3, #12
 8000990:	4d73      	ldr	r5, [pc, #460]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 8000992:	68ea      	ldr	r2, [r5, #12]
 8000994:	421a      	tst	r2, r3
 8000996:	d144      	bne.n	8000a22 <HAL_RCC_OscConfig+0x1f2>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8000998:	682b      	ldr	r3, [r5, #0]
 800099a:	059b      	lsls	r3, r3, #22
 800099c:	d503      	bpl.n	80009a6 <HAL_RCC_OscConfig+0x176>
 800099e:	69e3      	ldr	r3, [r4, #28]
 80009a0:	2b00      	cmp	r3, #0
 80009a2:	d100      	bne.n	80009a6 <HAL_RCC_OscConfig+0x176>
 80009a4:	e763      	b.n	800086e <HAL_RCC_OscConfig+0x3e>
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80009a6:	23e0      	movs	r3, #224	; 0xe0
 80009a8:	686a      	ldr	r2, [r5, #4]
 80009aa:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80009ac:	021b      	lsls	r3, r3, #8
 80009ae:	4e6c      	ldr	r6, [pc, #432]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 80009b0:	4013      	ands	r3, r2
 80009b2:	4298      	cmp	r0, r3
 80009b4:	d912      	bls.n	80009dc <HAL_RCC_OscConfig+0x1ac>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80009b6:	f7ff ff03 	bl	80007c0 <RCC_SetFlashLatencyFromMSIRange>
 80009ba:	2800      	cmp	r0, #0
 80009bc:	d000      	beq.n	80009c0 <HAL_RCC_OscConfig+0x190>
 80009be:	e756      	b.n	800086e <HAL_RCC_OscConfig+0x3e>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80009c0:	6872      	ldr	r2, [r6, #4]
 80009c2:	4b6b      	ldr	r3, [pc, #428]	; (8000b70 <HAL_RCC_OscConfig+0x340>)
 80009c4:	4013      	ands	r3, r2
 80009c6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80009c8:	4313      	orrs	r3, r2
 80009ca:	6073      	str	r3, [r6, #4]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80009cc:	6873      	ldr	r3, [r6, #4]
 80009ce:	6a22      	ldr	r2, [r4, #32]
 80009d0:	021b      	lsls	r3, r3, #8
 80009d2:	0612      	lsls	r2, r2, #24
 80009d4:	0a1b      	lsrs	r3, r3, #8
 80009d6:	4313      	orrs	r3, r2
 80009d8:	6073      	str	r3, [r6, #4]
 80009da:	e010      	b.n	80009fe <HAL_RCC_OscConfig+0x1ce>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80009dc:	6872      	ldr	r2, [r6, #4]
 80009de:	4b64      	ldr	r3, [pc, #400]	; (8000b70 <HAL_RCC_OscConfig+0x340>)
 80009e0:	4013      	ands	r3, r2
 80009e2:	4303      	orrs	r3, r0
 80009e4:	6073      	str	r3, [r6, #4]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80009e6:	6873      	ldr	r3, [r6, #4]
 80009e8:	6a22      	ldr	r2, [r4, #32]
 80009ea:	021b      	lsls	r3, r3, #8
 80009ec:	0612      	lsls	r2, r2, #24
 80009ee:	0a1b      	lsrs	r3, r3, #8
 80009f0:	4313      	orrs	r3, r2
 80009f2:	6073      	str	r3, [r6, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80009f4:	f7ff fee4 	bl	80007c0 <RCC_SetFlashLatencyFromMSIRange>
 80009f8:	2800      	cmp	r0, #0
 80009fa:	d000      	beq.n	80009fe <HAL_RCC_OscConfig+0x1ce>
 80009fc:	e737      	b.n	800086e <HAL_RCC_OscConfig+0x3e>
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 80009fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000a00:	68ea      	ldr	r2, [r5, #12]
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000a02:	0b59      	lsrs	r1, r3, #13
 8000a04:	2380      	movs	r3, #128	; 0x80
 8000a06:	3101      	adds	r1, #1
 8000a08:	021b      	lsls	r3, r3, #8
 8000a0a:	408b      	lsls	r3, r1
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000a0c:	0612      	lsls	r2, r2, #24
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000a0e:	4959      	ldr	r1, [pc, #356]	; (8000b74 <HAL_RCC_OscConfig+0x344>)
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000a10:	0f12      	lsrs	r2, r2, #28
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000a12:	5c8a      	ldrb	r2, [r1, r2]
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000a14:	2000      	movs	r0, #0
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000a16:	40d3      	lsrs	r3, r2
 8000a18:	4a57      	ldr	r2, [pc, #348]	; (8000b78 <HAL_RCC_OscConfig+0x348>)
 8000a1a:	6013      	str	r3, [r2, #0]
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000a1c:	f7ff fd14 	bl	8000448 <HAL_InitTick>
 8000a20:	e036      	b.n	8000a90 <HAL_RCC_OscConfig+0x260>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8000a22:	69e3      	ldr	r3, [r4, #28]
 8000a24:	2b00      	cmp	r3, #0
 8000a26:	d021      	beq.n	8000a6c <HAL_RCC_OscConfig+0x23c>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8000a28:	2280      	movs	r2, #128	; 0x80
 8000a2a:	682b      	ldr	r3, [r5, #0]
 8000a2c:	0052      	lsls	r2, r2, #1
 8000a2e:	4313      	orrs	r3, r2
 8000a30:	602b      	str	r3, [r5, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a32:	f7ff fd35 	bl	80004a0 <HAL_GetTick>

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8000a36:	2680      	movs	r6, #128	; 0x80
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a38:	0007      	movs	r7, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8000a3a:	00b6      	lsls	r6, r6, #2
 8000a3c:	682b      	ldr	r3, [r5, #0]
 8000a3e:	4a48      	ldr	r2, [pc, #288]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 8000a40:	4233      	tst	r3, r6
 8000a42:	d105      	bne.n	8000a50 <HAL_RCC_OscConfig+0x220>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000a44:	f7ff fd2c 	bl	80004a0 <HAL_GetTick>
 8000a48:	1bc0      	subs	r0, r0, r7
 8000a4a:	2802      	cmp	r0, #2
 8000a4c:	d9f6      	bls.n	8000a3c <HAL_RCC_OscConfig+0x20c>
 8000a4e:	e740      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000a50:	6851      	ldr	r1, [r2, #4]
 8000a52:	4b47      	ldr	r3, [pc, #284]	; (8000b70 <HAL_RCC_OscConfig+0x340>)
 8000a54:	400b      	ands	r3, r1
 8000a56:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000a58:	430b      	orrs	r3, r1
 8000a5a:	6053      	str	r3, [r2, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000a5c:	6853      	ldr	r3, [r2, #4]
 8000a5e:	6a21      	ldr	r1, [r4, #32]
 8000a60:	021b      	lsls	r3, r3, #8
 8000a62:	0609      	lsls	r1, r1, #24
 8000a64:	0a1b      	lsrs	r3, r3, #8
 8000a66:	430b      	orrs	r3, r1
 8000a68:	6053      	str	r3, [r2, #4]
 8000a6a:	e011      	b.n	8000a90 <HAL_RCC_OscConfig+0x260>

      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8000a6c:	682a      	ldr	r2, [r5, #0]
 8000a6e:	4b43      	ldr	r3, [pc, #268]	; (8000b7c <HAL_RCC_OscConfig+0x34c>)

        /* Get Start Tick */
        tickstart = HAL_GetTick();

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8000a70:	2680      	movs	r6, #128	; 0x80

      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8000a72:	4013      	ands	r3, r2
 8000a74:	602b      	str	r3, [r5, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a76:	f7ff fd13 	bl	80004a0 <HAL_GetTick>
 8000a7a:	0007      	movs	r7, r0

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8000a7c:	00b6      	lsls	r6, r6, #2
 8000a7e:	682b      	ldr	r3, [r5, #0]
 8000a80:	4233      	tst	r3, r6
 8000a82:	d005      	beq.n	8000a90 <HAL_RCC_OscConfig+0x260>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000a84:	f7ff fd0c 	bl	80004a0 <HAL_GetTick>
 8000a88:	1bc0      	subs	r0, r0, r7
 8000a8a:	2802      	cmp	r0, #2
 8000a8c:	d9f7      	bls.n	8000a7e <HAL_RCC_OscConfig+0x24e>
 8000a8e:	e720      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        }
      }
    }
  }  
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000a90:	6823      	ldr	r3, [r4, #0]
 8000a92:	071b      	lsls	r3, r3, #28
 8000a94:	d403      	bmi.n	8000a9e <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000a96:	6823      	ldr	r3, [r4, #0]
 8000a98:	075b      	lsls	r3, r3, #29
 8000a9a:	d425      	bmi.n	8000ae8 <HAL_RCC_OscConfig+0x2b8>
 8000a9c:	e0a8      	b.n	8000bf0 <HAL_RCC_OscConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000a9e:	6963      	ldr	r3, [r4, #20]
 8000aa0:	2201      	movs	r2, #1
 8000aa2:	4d2f      	ldr	r5, [pc, #188]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 8000aa4:	2b00      	cmp	r3, #0
 8000aa6:	d00f      	beq.n	8000ac8 <HAL_RCC_OscConfig+0x298>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000aa8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000aaa:	2602      	movs	r6, #2
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000aac:	4313      	orrs	r3, r2
 8000aae:	652b      	str	r3, [r5, #80]	; 0x50
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000ab0:	f7ff fcf6 	bl	80004a0 <HAL_GetTick>
 8000ab4:	0007      	movs	r7, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000ab6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000ab8:	4233      	tst	r3, r6
 8000aba:	d1ec      	bne.n	8000a96 <HAL_RCC_OscConfig+0x266>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000abc:	f7ff fcf0 	bl	80004a0 <HAL_GetTick>
 8000ac0:	1bc0      	subs	r0, r0, r7
 8000ac2:	2802      	cmp	r0, #2
 8000ac4:	d9f7      	bls.n	8000ab6 <HAL_RCC_OscConfig+0x286>
 8000ac6:	e704      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000ac8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000aca:	2602      	movs	r6, #2
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000acc:	4393      	bics	r3, r2
 8000ace:	652b      	str	r3, [r5, #80]	; 0x50
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000ad0:	f7ff fce6 	bl	80004a0 <HAL_GetTick>
 8000ad4:	0007      	movs	r7, r0
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000ad6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000ad8:	4233      	tst	r3, r6
 8000ada:	d0dc      	beq.n	8000a96 <HAL_RCC_OscConfig+0x266>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000adc:	f7ff fce0 	bl	80004a0 <HAL_GetTick>
 8000ae0:	1bc0      	subs	r0, r0, r7
 8000ae2:	2802      	cmp	r0, #2
 8000ae4:	d9f7      	bls.n	8000ad6 <HAL_RCC_OscConfig+0x2a6>
 8000ae6:	e6f4      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000ae8:	2280      	movs	r2, #128	; 0x80
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8000aea:	2100      	movs	r1, #0
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000aec:	4d1c      	ldr	r5, [pc, #112]	; (8000b60 <HAL_RCC_OscConfig+0x330>)
 8000aee:	0552      	lsls	r2, r2, #21
 8000af0:	6bab      	ldr	r3, [r5, #56]	; 0x38
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8000af2:	9100      	str	r1, [sp, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000af4:	4213      	tst	r3, r2
 8000af6:	d104      	bne.n	8000b02 <HAL_RCC_OscConfig+0x2d2>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000af8:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8000afa:	4313      	orrs	r3, r2
 8000afc:	63ab      	str	r3, [r5, #56]	; 0x38
      pwrclkchanged = SET;
 8000afe:	2301      	movs	r3, #1
 8000b00:	9300      	str	r3, [sp, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000b02:	2780      	movs	r7, #128	; 0x80
 8000b04:	4e1e      	ldr	r6, [pc, #120]	; (8000b80 <HAL_RCC_OscConfig+0x350>)
 8000b06:	007f      	lsls	r7, r7, #1
 8000b08:	6833      	ldr	r3, [r6, #0]
 8000b0a:	423b      	tst	r3, r7
 8000b0c:	d007      	beq.n	8000b1e <HAL_RCC_OscConfig+0x2ee>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b0e:	2180      	movs	r1, #128	; 0x80
 8000b10:	68a3      	ldr	r3, [r4, #8]
 8000b12:	0049      	lsls	r1, r1, #1
 8000b14:	428b      	cmp	r3, r1
 8000b16:	d112      	bne.n	8000b3e <HAL_RCC_OscConfig+0x30e>
 8000b18:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8000b1a:	4313      	orrs	r3, r2
 8000b1c:	e047      	b.n	8000bae <HAL_RCC_OscConfig+0x37e>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000b1e:	6833      	ldr	r3, [r6, #0]
 8000b20:	433b      	orrs	r3, r7
 8000b22:	6033      	str	r3, [r6, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8000b24:	f7ff fcbc 	bl	80004a0 <HAL_GetTick>
 8000b28:	9001      	str	r0, [sp, #4]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000b2a:	6833      	ldr	r3, [r6, #0]
 8000b2c:	423b      	tst	r3, r7
 8000b2e:	d1ee      	bne.n	8000b0e <HAL_RCC_OscConfig+0x2de>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000b30:	f7ff fcb6 	bl	80004a0 <HAL_GetTick>
 8000b34:	9b01      	ldr	r3, [sp, #4]
 8000b36:	1ac0      	subs	r0, r0, r3
 8000b38:	2864      	cmp	r0, #100	; 0x64
 8000b3a:	d9f6      	bls.n	8000b2a <HAL_RCC_OscConfig+0x2fa>
 8000b3c:	e6c9      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b3e:	2b00      	cmp	r3, #0
 8000b40:	d122      	bne.n	8000b88 <HAL_RCC_OscConfig+0x358>
 8000b42:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8000b44:	4b0d      	ldr	r3, [pc, #52]	; (8000b7c <HAL_RCC_OscConfig+0x34c>)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b46:	2780      	movs	r7, #128	; 0x80
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b48:	4013      	ands	r3, r2
 8000b4a:	652b      	str	r3, [r5, #80]	; 0x50
 8000b4c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8000b4e:	4b0d      	ldr	r3, [pc, #52]	; (8000b84 <HAL_RCC_OscConfig+0x354>)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b50:	00bf      	lsls	r7, r7, #2
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b52:	4013      	ands	r3, r2
 8000b54:	652b      	str	r3, [r5, #80]	; 0x50
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000b56:	f7ff fca3 	bl	80004a0 <HAL_GetTick>
 8000b5a:	0006      	movs	r6, r0
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b5c:	e03e      	b.n	8000bdc <HAL_RCC_OscConfig+0x3ac>
 8000b5e:	46c0      	nop			; (mov r8, r8)
 8000b60:	40021000 	.word	0x40021000
 8000b64:	fffeffff 	.word	0xfffeffff
 8000b68:	fffbffff 	.word	0xfffbffff
 8000b6c:	ffffe0ff 	.word	0xffffe0ff
 8000b70:	ffff1fff 	.word	0xffff1fff
 8000b74:	08001cf1 	.word	0x08001cf1
 8000b78:	20000000 	.word	0x20000000
 8000b7c:	fffffeff 	.word	0xfffffeff
 8000b80:	40007000 	.word	0x40007000
 8000b84:	fffffbff 	.word	0xfffffbff
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b88:	22a0      	movs	r2, #160	; 0xa0
 8000b8a:	00d2      	lsls	r2, r2, #3
 8000b8c:	4293      	cmp	r3, r2
 8000b8e:	d107      	bne.n	8000ba0 <HAL_RCC_OscConfig+0x370>
 8000b90:	2380      	movs	r3, #128	; 0x80
 8000b92:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8000b94:	00db      	lsls	r3, r3, #3
 8000b96:	431a      	orrs	r2, r3
 8000b98:	652a      	str	r2, [r5, #80]	; 0x50
 8000b9a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000b9c:	430b      	orrs	r3, r1
 8000b9e:	e006      	b.n	8000bae <HAL_RCC_OscConfig+0x37e>
 8000ba0:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8000ba2:	4b57      	ldr	r3, [pc, #348]	; (8000d00 <HAL_RCC_OscConfig+0x4d0>)
 8000ba4:	4013      	ands	r3, r2
 8000ba6:	652b      	str	r3, [r5, #80]	; 0x50
 8000ba8:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8000baa:	4b56      	ldr	r3, [pc, #344]	; (8000d04 <HAL_RCC_OscConfig+0x4d4>)
 8000bac:	4013      	ands	r3, r2
 8000bae:	652b      	str	r3, [r5, #80]	; 0x50
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000bb0:	f7ff fc76 	bl	80004a0 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000bb4:	2780      	movs	r7, #128	; 0x80
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000bb6:	0006      	movs	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000bb8:	00bf      	lsls	r7, r7, #2
 8000bba:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000bbc:	423b      	tst	r3, r7
 8000bbe:	d110      	bne.n	8000be2 <HAL_RCC_OscConfig+0x3b2>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000bc0:	f7ff fc6e 	bl	80004a0 <HAL_GetTick>
 8000bc4:	4b50      	ldr	r3, [pc, #320]	; (8000d08 <HAL_RCC_OscConfig+0x4d8>)
 8000bc6:	1b80      	subs	r0, r0, r6
 8000bc8:	4298      	cmp	r0, r3
 8000bca:	d9f6      	bls.n	8000bba <HAL_RCC_OscConfig+0x38a>
 8000bcc:	e681      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000bce:	f7ff fc67 	bl	80004a0 <HAL_GetTick>
 8000bd2:	4b4d      	ldr	r3, [pc, #308]	; (8000d08 <HAL_RCC_OscConfig+0x4d8>)
 8000bd4:	1b80      	subs	r0, r0, r6
 8000bd6:	4298      	cmp	r0, r3
 8000bd8:	d900      	bls.n	8000bdc <HAL_RCC_OscConfig+0x3ac>
 8000bda:	e67a      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000bdc:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000bde:	423b      	tst	r3, r7
 8000be0:	d1f5      	bne.n	8000bce <HAL_RCC_OscConfig+0x39e>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8000be2:	9b00      	ldr	r3, [sp, #0]
 8000be4:	2b01      	cmp	r3, #1
 8000be6:	d103      	bne.n	8000bf0 <HAL_RCC_OscConfig+0x3c0>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8000be8:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8000bea:	4b48      	ldr	r3, [pc, #288]	; (8000d0c <HAL_RCC_OscConfig+0x4dc>)
 8000bec:	4013      	ands	r3, r2
 8000bee:	63ab      	str	r3, [r5, #56]	; 0x38
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8000bf0:	6823      	ldr	r3, [r4, #0]
 8000bf2:	069b      	lsls	r3, r3, #26
 8000bf4:	d403      	bmi.n	8000bfe <HAL_RCC_OscConfig+0x3ce>
#endif /* RCC_HSI48_SUPPORT */
       
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000bf6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000bf8:	2a00      	cmp	r2, #0
 8000bfa:	d132      	bne.n	8000c62 <HAL_RCC_OscConfig+0x432>
 8000bfc:	e05e      	b.n	8000cbc <HAL_RCC_OscConfig+0x48c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8000bfe:	69a2      	ldr	r2, [r4, #24]
 8000c00:	2101      	movs	r1, #1
 8000c02:	4d43      	ldr	r5, [pc, #268]	; (8000d10 <HAL_RCC_OscConfig+0x4e0>)
 8000c04:	4b43      	ldr	r3, [pc, #268]	; (8000d14 <HAL_RCC_OscConfig+0x4e4>)
 8000c06:	2a00      	cmp	r2, #0
 8000c08:	d017      	beq.n	8000c3a <HAL_RCC_OscConfig+0x40a>
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 8000c0a:	68aa      	ldr	r2, [r5, #8]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 8000c0c:	2602      	movs	r6, #2

      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 8000c0e:	430a      	orrs	r2, r1
 8000c10:	60aa      	str	r2, [r5, #8]
 8000c12:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000c14:	4311      	orrs	r1, r2
 8000c16:	6369      	str	r1, [r5, #52]	; 0x34
 8000c18:	2180      	movs	r1, #128	; 0x80
 8000c1a:	6a1a      	ldr	r2, [r3, #32]
 8000c1c:	0189      	lsls	r1, r1, #6
 8000c1e:	430a      	orrs	r2, r1
 8000c20:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000c22:	f7ff fc3d 	bl	80004a0 <HAL_GetTick>
 8000c26:	0007      	movs	r7, r0
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 8000c28:	68ab      	ldr	r3, [r5, #8]
 8000c2a:	4233      	tst	r3, r6
 8000c2c:	d1e3      	bne.n	8000bf6 <HAL_RCC_OscConfig+0x3c6>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000c2e:	f7ff fc37 	bl	80004a0 <HAL_GetTick>
 8000c32:	1bc0      	subs	r0, r0, r7
 8000c34:	2802      	cmp	r0, #2
 8000c36:	d9f7      	bls.n	8000c28 <HAL_RCC_OscConfig+0x3f8>
 8000c38:	e64b      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        } 
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 8000c3a:	68aa      	ldr	r2, [r5, #8]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 8000c3c:	2602      	movs	r6, #2
        } 
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 8000c3e:	438a      	bics	r2, r1
 8000c40:	60aa      	str	r2, [r5, #8]
 8000c42:	6a19      	ldr	r1, [r3, #32]
 8000c44:	4a34      	ldr	r2, [pc, #208]	; (8000d18 <HAL_RCC_OscConfig+0x4e8>)
 8000c46:	400a      	ands	r2, r1
 8000c48:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000c4a:	f7ff fc29 	bl	80004a0 <HAL_GetTick>
 8000c4e:	0007      	movs	r7, r0
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 8000c50:	68ab      	ldr	r3, [r5, #8]
 8000c52:	4233      	tst	r3, r6
 8000c54:	d0cf      	beq.n	8000bf6 <HAL_RCC_OscConfig+0x3c6>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000c56:	f7ff fc23 	bl	80004a0 <HAL_GetTick>
 8000c5a:	1bc0      	subs	r0, r0, r7
 8000c5c:	2802      	cmp	r0, #2
 8000c5e:	d9f7      	bls.n	8000c50 <HAL_RCC_OscConfig+0x420>
 8000c60:	e637      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000c62:	230c      	movs	r3, #12
 8000c64:	4d2a      	ldr	r5, [pc, #168]	; (8000d10 <HAL_RCC_OscConfig+0x4e0>)
        }
      }
    }
    else
    {
      return HAL_ERROR;
 8000c66:	2001      	movs	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000c68:	68e9      	ldr	r1, [r5, #12]
 8000c6a:	400b      	ands	r3, r1
 8000c6c:	2b0c      	cmp	r3, #12
 8000c6e:	d044      	beq.n	8000cfa <HAL_RCC_OscConfig+0x4ca>
 8000c70:	4b2a      	ldr	r3, [pc, #168]	; (8000d1c <HAL_RCC_OscConfig+0x4ec>)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000c72:	2a02      	cmp	r2, #2
 8000c74:	d130      	bne.n	8000cd8 <HAL_RCC_OscConfig+0x4a8>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000c76:	682a      	ldr	r2, [r5, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000c78:	2680      	movs	r6, #128	; 0x80
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000c7a:	4013      	ands	r3, r2
 8000c7c:	602b      	str	r3, [r5, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000c7e:	f7ff fc0f 	bl	80004a0 <HAL_GetTick>
 8000c82:	0007      	movs	r7, r0
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000c84:	04b6      	lsls	r6, r6, #18
 8000c86:	682b      	ldr	r3, [r5, #0]
 8000c88:	4921      	ldr	r1, [pc, #132]	; (8000d10 <HAL_RCC_OscConfig+0x4e0>)
 8000c8a:	4233      	tst	r3, r6
 8000c8c:	d118      	bne.n	8000cc0 <HAL_RCC_OscConfig+0x490>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c8e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8000c90:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000c92:	68cb      	ldr	r3, [r1, #12]
 8000c94:	4310      	orrs	r0, r2
 8000c96:	6b62      	ldr	r2, [r4, #52]	; 0x34
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000c98:	2480      	movs	r4, #128	; 0x80
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c9a:	4310      	orrs	r0, r2
 8000c9c:	4a20      	ldr	r2, [pc, #128]	; (8000d20 <HAL_RCC_OscConfig+0x4f0>)
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000c9e:	04a4      	lsls	r4, r4, #18
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000ca0:	4013      	ands	r3, r2
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000ca2:	2280      	movs	r2, #128	; 0x80
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000ca4:	4303      	orrs	r3, r0
 8000ca6:	60cb      	str	r3, [r1, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000ca8:	680b      	ldr	r3, [r1, #0]
 8000caa:	0452      	lsls	r2, r2, #17
 8000cac:	4313      	orrs	r3, r2
 8000cae:	600b      	str	r3, [r1, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000cb0:	f7ff fbf6 	bl	80004a0 <HAL_GetTick>
 8000cb4:	0006      	movs	r6, r0
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000cb6:	682b      	ldr	r3, [r5, #0]
 8000cb8:	4223      	tst	r3, r4
 8000cba:	d007      	beq.n	8000ccc <HAL_RCC_OscConfig+0x49c>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8000cbc:	2000      	movs	r0, #0
 8000cbe:	e01c      	b.n	8000cfa <HAL_RCC_OscConfig+0x4ca>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000cc0:	f7ff fbee 	bl	80004a0 <HAL_GetTick>
 8000cc4:	1bc0      	subs	r0, r0, r7
 8000cc6:	2802      	cmp	r0, #2
 8000cc8:	d9dd      	bls.n	8000c86 <HAL_RCC_OscConfig+0x456>
 8000cca:	e602      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000ccc:	f7ff fbe8 	bl	80004a0 <HAL_GetTick>
 8000cd0:	1b80      	subs	r0, r0, r6
 8000cd2:	2802      	cmp	r0, #2
 8000cd4:	d9ef      	bls.n	8000cb6 <HAL_RCC_OscConfig+0x486>
 8000cd6:	e5fc      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000cd8:	682a      	ldr	r2, [r5, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000cda:	2480      	movs	r4, #128	; 0x80
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000cdc:	4013      	ands	r3, r2
 8000cde:	602b      	str	r3, [r5, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000ce0:	f7ff fbde 	bl	80004a0 <HAL_GetTick>
 8000ce4:	0006      	movs	r6, r0
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000ce6:	04a4      	lsls	r4, r4, #18
 8000ce8:	682b      	ldr	r3, [r5, #0]
 8000cea:	4223      	tst	r3, r4
 8000cec:	d0e6      	beq.n	8000cbc <HAL_RCC_OscConfig+0x48c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000cee:	f7ff fbd7 	bl	80004a0 <HAL_GetTick>
 8000cf2:	1b80      	subs	r0, r0, r6
 8000cf4:	2802      	cmp	r0, #2
 8000cf6:	d9f7      	bls.n	8000ce8 <HAL_RCC_OscConfig+0x4b8>
 8000cf8:	e5eb      	b.n	80008d2 <HAL_RCC_OscConfig+0xa2>
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 8000cfa:	b005      	add	sp, #20
 8000cfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cfe:	46c0      	nop			; (mov r8, r8)
 8000d00:	fffffeff 	.word	0xfffffeff
 8000d04:	fffffbff 	.word	0xfffffbff
 8000d08:	00001388 	.word	0x00001388
 8000d0c:	efffffff 	.word	0xefffffff
 8000d10:	40021000 	.word	0x40021000
 8000d14:	40010000 	.word	0x40010000
 8000d18:	ffffdfff 	.word	0xffffdfff
 8000d1c:	feffffff 	.word	0xfeffffff
 8000d20:	ff02ffff 	.word	0xff02ffff

08000d24 <HAL_RCC_GetSysClockFreq>:
  uint32_t sysclockfreq = 0;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000d24:	220c      	movs	r2, #12
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
  uint32_t sysclockfreq = 0;
  
  tmpreg = RCC->CFGR;
 8000d26:	4b18      	ldr	r3, [pc, #96]	; (8000d88 <HAL_RCC_GetSysClockFreq+0x64>)
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8000d28:	b510      	push	{r4, lr}
  uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
  uint32_t sysclockfreq = 0;
  
  tmpreg = RCC->CFGR;
 8000d2a:	68d9      	ldr	r1, [r3, #12]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000d2c:	400a      	ands	r2, r1
 8000d2e:	2a08      	cmp	r2, #8
 8000d30:	d026      	beq.n	8000d80 <HAL_RCC_GetSysClockFreq+0x5c>
 8000d32:	2a0c      	cmp	r2, #12
 8000d34:	d006      	beq.n	8000d44 <HAL_RCC_GetSysClockFreq+0x20>
 8000d36:	2a04      	cmp	r2, #4
 8000d38:	d11a      	bne.n	8000d70 <HAL_RCC_GetSysClockFreq+0x4c>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0)
 8000d3a:	681b      	ldr	r3, [r3, #0]
 8000d3c:	06db      	lsls	r3, r3, #27
 8000d3e:	d421      	bmi.n	8000d84 <HAL_RCC_GetSysClockFreq+0x60>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
      }
      else 
      {
        sysclockfreq =  HSI_VALUE;
 8000d40:	4812      	ldr	r0, [pc, #72]	; (8000d8c <HAL_RCC_GetSysClockFreq+0x68>)
 8000d42:	e020      	b.n	8000d86 <HAL_RCC_GetSysClockFreq+0x62>
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8000d44:	028a      	lsls	r2, r1, #10
 8000d46:	4812      	ldr	r0, [pc, #72]	; (8000d90 <HAL_RCC_GetSysClockFreq+0x6c>)
 8000d48:	0f12      	lsrs	r2, r2, #28
 8000d4a:	5c80      	ldrb	r0, [r0, r2]
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
 8000d4c:	0209      	lsls	r1, r1, #8
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8000d4e:	68da      	ldr	r2, [r3, #12]
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
 8000d50:	0f89      	lsrs	r1, r1, #30
 8000d52:	3101      	adds	r1, #1
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8000d54:	03d2      	lsls	r2, r2, #15
 8000d56:	d501      	bpl.n	8000d5c <HAL_RCC_GetSysClockFreq+0x38>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE * pllm) / plld;
 8000d58:	4b0e      	ldr	r3, [pc, #56]	; (8000d94 <HAL_RCC_GetSysClockFreq+0x70>)
 8000d5a:	e005      	b.n	8000d68 <HAL_RCC_GetSysClockFreq+0x44>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0)
 8000d5c:	681b      	ldr	r3, [r3, #0]
 8000d5e:	06db      	lsls	r3, r3, #27
 8000d60:	d501      	bpl.n	8000d66 <HAL_RCC_GetSysClockFreq+0x42>
        {
          pllvco = ((HSI_VALUE >> 2) * pllm) / plld;
 8000d62:	4b0d      	ldr	r3, [pc, #52]	; (8000d98 <HAL_RCC_GetSysClockFreq+0x74>)
 8000d64:	e000      	b.n	8000d68 <HAL_RCC_GetSysClockFreq+0x44>
        }
        else 
        {
         pllvco = (HSI_VALUE * pllm) / plld;
 8000d66:	4b09      	ldr	r3, [pc, #36]	; (8000d8c <HAL_RCC_GetSysClockFreq+0x68>)
 8000d68:	4358      	muls	r0, r3
 8000d6a:	f7ff f9d7 	bl	800011c <__aeabi_uidiv>
 8000d6e:	e00a      	b.n	8000d86 <HAL_RCC_GetSysClockFreq+0x62>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_BITNUMBER;
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
 8000d70:	2080      	movs	r0, #128	; 0x80
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_BITNUMBER;
 8000d72:	685b      	ldr	r3, [r3, #4]
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
 8000d74:	0200      	lsls	r0, r0, #8
 8000d76:	041b      	lsls	r3, r3, #16
 8000d78:	0f5b      	lsrs	r3, r3, #29
 8000d7a:	3301      	adds	r3, #1
 8000d7c:	4098      	lsls	r0, r3
 8000d7e:	e002      	b.n	8000d86 <HAL_RCC_GetSysClockFreq+0x62>
      }
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8000d80:	4804      	ldr	r0, [pc, #16]	; (8000d94 <HAL_RCC_GetSysClockFreq+0x70>)
 8000d82:	e000      	b.n	8000d86 <HAL_RCC_GetSysClockFreq+0x62>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0)
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 8000d84:	4804      	ldr	r0, [pc, #16]	; (8000d98 <HAL_RCC_GetSysClockFreq+0x74>)
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
      break;
    }
  }
  return sysclockfreq;
}
 8000d86:	bd10      	pop	{r4, pc}
 8000d88:	40021000 	.word	0x40021000
 8000d8c:	00f42400 	.word	0x00f42400
 8000d90:	08001d09 	.word	0x08001d09
 8000d94:	007a1200 	.word	0x007a1200
 8000d98:	003d0900 	.word	0x003d0900

08000d9c <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000d9c:	2301      	movs	r3, #1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000d9e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000da0:	4e51      	ldr	r6, [pc, #324]	; (8000ee8 <HAL_RCC_ClockConfig+0x14c>)
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000da2:	0005      	movs	r5, r0
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000da4:	6832      	ldr	r2, [r6, #0]
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000da6:	9101      	str	r1, [sp, #4]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000da8:	401a      	ands	r2, r3
 8000daa:	428a      	cmp	r2, r1
 8000dac:	d30a      	bcc.n	8000dc4 <HAL_RCC_ClockConfig+0x28>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000dae:	682a      	ldr	r2, [r5, #0]
 8000db0:	0793      	lsls	r3, r2, #30
 8000db2:	d513      	bpl.n	8000ddc <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000db4:	20f0      	movs	r0, #240	; 0xf0
 8000db6:	494d      	ldr	r1, [pc, #308]	; (8000eec <HAL_RCC_ClockConfig+0x150>)
 8000db8:	68cb      	ldr	r3, [r1, #12]
 8000dba:	4383      	bics	r3, r0
 8000dbc:	68a8      	ldr	r0, [r5, #8]
 8000dbe:	4303      	orrs	r3, r0
 8000dc0:	60cb      	str	r3, [r1, #12]
 8000dc2:	e00b      	b.n	8000ddc <HAL_RCC_ClockConfig+0x40>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000dc4:	6832      	ldr	r2, [r6, #0]
 8000dc6:	9901      	ldr	r1, [sp, #4]
 8000dc8:	439a      	bics	r2, r3
 8000dca:	430a      	orrs	r2, r1
 8000dcc:	6032      	str	r2, [r6, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000dce:	6832      	ldr	r2, [r6, #0]
 8000dd0:	4013      	ands	r3, r2
 8000dd2:	9a01      	ldr	r2, [sp, #4]
 8000dd4:	429a      	cmp	r2, r3
 8000dd6:	d0ea      	beq.n	8000dae <HAL_RCC_ClockConfig+0x12>
    {
      return HAL_ERROR;
 8000dd8:	2001      	movs	r0, #1
 8000dda:	e083      	b.n	8000ee4 <HAL_RCC_ClockConfig+0x148>
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000ddc:	07d3      	lsls	r3, r2, #31
 8000dde:	d407      	bmi.n	8000df0 <HAL_RCC_ClockConfig+0x54>
        }
      }
    }
  }    
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8000de0:	2301      	movs	r3, #1
 8000de2:	6831      	ldr	r1, [r6, #0]
 8000de4:	9801      	ldr	r0, [sp, #4]
 8000de6:	4a40      	ldr	r2, [pc, #256]	; (8000ee8 <HAL_RCC_ClockConfig+0x14c>)
 8000de8:	4019      	ands	r1, r3
 8000dea:	4288      	cmp	r0, r1
 8000dec:	d353      	bcc.n	8000e96 <HAL_RCC_ClockConfig+0xfa>
 8000dee:	e058      	b.n	8000ea2 <HAL_RCC_ClockConfig+0x106>
 8000df0:	4c3e      	ldr	r4, [pc, #248]	; (8000eec <HAL_RCC_ClockConfig+0x150>)
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000df2:	686b      	ldr	r3, [r5, #4]
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000df4:	6822      	ldr	r2, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000df6:	2b02      	cmp	r3, #2
 8000df8:	d102      	bne.n	8000e00 <HAL_RCC_ClockConfig+0x64>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000dfa:	0392      	lsls	r2, r2, #14
 8000dfc:	d40c      	bmi.n	8000e18 <HAL_RCC_ClockConfig+0x7c>
 8000dfe:	e7eb      	b.n	8000dd8 <HAL_RCC_ClockConfig+0x3c>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000e00:	2b03      	cmp	r3, #3
 8000e02:	d102      	bne.n	8000e0a <HAL_RCC_ClockConfig+0x6e>
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000e04:	0192      	lsls	r2, r2, #6
 8000e06:	d407      	bmi.n	8000e18 <HAL_RCC_ClockConfig+0x7c>
 8000e08:	e7e6      	b.n	8000dd8 <HAL_RCC_ClockConfig+0x3c>
      {
        return HAL_ERROR;
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8000e0a:	2b01      	cmp	r3, #1
 8000e0c:	d102      	bne.n	8000e14 <HAL_RCC_ClockConfig+0x78>
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000e0e:	0752      	lsls	r2, r2, #29
 8000e10:	d402      	bmi.n	8000e18 <HAL_RCC_ClockConfig+0x7c>
 8000e12:	e7e1      	b.n	8000dd8 <HAL_RCC_ClockConfig+0x3c>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8000e14:	0592      	lsls	r2, r2, #22
 8000e16:	d5df      	bpl.n	8000dd8 <HAL_RCC_ClockConfig+0x3c>
      {
        return HAL_ERROR;
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000e18:	2103      	movs	r1, #3
 8000e1a:	68e2      	ldr	r2, [r4, #12]
 8000e1c:	438a      	bics	r2, r1
 8000e1e:	4313      	orrs	r3, r2
 8000e20:	60e3      	str	r3, [r4, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8000e22:	f7ff fb3d 	bl	80004a0 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000e26:	686b      	ldr	r3, [r5, #4]
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8000e28:	0007      	movs	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000e2a:	2b02      	cmp	r3, #2
 8000e2c:	d10c      	bne.n	8000e48 <HAL_RCC_ClockConfig+0xac>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000e2e:	220c      	movs	r2, #12
 8000e30:	68e3      	ldr	r3, [r4, #12]
 8000e32:	4013      	ands	r3, r2
 8000e34:	2b08      	cmp	r3, #8
 8000e36:	d0d3      	beq.n	8000de0 <HAL_RCC_ClockConfig+0x44>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000e38:	f7ff fb32 	bl	80004a0 <HAL_GetTick>
 8000e3c:	4b2c      	ldr	r3, [pc, #176]	; (8000ef0 <HAL_RCC_ClockConfig+0x154>)
 8000e3e:	1bc0      	subs	r0, r0, r7
 8000e40:	4298      	cmp	r0, r3
 8000e42:	d9f4      	bls.n	8000e2e <HAL_RCC_ClockConfig+0x92>
        {
          return HAL_TIMEOUT;
 8000e44:	2003      	movs	r0, #3
 8000e46:	e04d      	b.n	8000ee4 <HAL_RCC_ClockConfig+0x148>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000e48:	2b03      	cmp	r3, #3
 8000e4a:	d10b      	bne.n	8000e64 <HAL_RCC_ClockConfig+0xc8>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000e4c:	220c      	movs	r2, #12
 8000e4e:	68e3      	ldr	r3, [r4, #12]
 8000e50:	4013      	ands	r3, r2
 8000e52:	4293      	cmp	r3, r2
 8000e54:	d0c4      	beq.n	8000de0 <HAL_RCC_ClockConfig+0x44>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000e56:	f7ff fb23 	bl	80004a0 <HAL_GetTick>
 8000e5a:	4b25      	ldr	r3, [pc, #148]	; (8000ef0 <HAL_RCC_ClockConfig+0x154>)
 8000e5c:	1bc0      	subs	r0, r0, r7
 8000e5e:	4298      	cmp	r0, r3
 8000e60:	d9f4      	bls.n	8000e4c <HAL_RCC_ClockConfig+0xb0>
 8000e62:	e7ef      	b.n	8000e44 <HAL_RCC_ClockConfig+0xa8>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8000e64:	2b01      	cmp	r3, #1
 8000e66:	d111      	bne.n	8000e8c <HAL_RCC_ClockConfig+0xf0>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000e68:	220c      	movs	r2, #12
 8000e6a:	68e3      	ldr	r3, [r4, #12]
 8000e6c:	4013      	ands	r3, r2
 8000e6e:	2b04      	cmp	r3, #4
 8000e70:	d0b6      	beq.n	8000de0 <HAL_RCC_ClockConfig+0x44>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000e72:	f7ff fb15 	bl	80004a0 <HAL_GetTick>
 8000e76:	4b1e      	ldr	r3, [pc, #120]	; (8000ef0 <HAL_RCC_ClockConfig+0x154>)
 8000e78:	1bc0      	subs	r0, r0, r7
 8000e7a:	4298      	cmp	r0, r3
 8000e7c:	d9f4      	bls.n	8000e68 <HAL_RCC_ClockConfig+0xcc>
 8000e7e:	e7e1      	b.n	8000e44 <HAL_RCC_ClockConfig+0xa8>
    }      
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000e80:	f7ff fb0e 	bl	80004a0 <HAL_GetTick>
 8000e84:	4b1a      	ldr	r3, [pc, #104]	; (8000ef0 <HAL_RCC_ClockConfig+0x154>)
 8000e86:	1bc0      	subs	r0, r0, r7
 8000e88:	4298      	cmp	r0, r3
 8000e8a:	d8db      	bhi.n	8000e44 <HAL_RCC_ClockConfig+0xa8>
        }
      }
    }      
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 8000e8c:	220c      	movs	r2, #12
 8000e8e:	68e3      	ldr	r3, [r4, #12]
 8000e90:	4213      	tst	r3, r2
 8000e92:	d1f5      	bne.n	8000e80 <HAL_RCC_ClockConfig+0xe4>
 8000e94:	e7a4      	b.n	8000de0 <HAL_RCC_ClockConfig+0x44>
  }    
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000e96:	6811      	ldr	r1, [r2, #0]
 8000e98:	4399      	bics	r1, r3
 8000e9a:	6011      	str	r1, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000e9c:	6812      	ldr	r2, [r2, #0]
 8000e9e:	421a      	tst	r2, r3
 8000ea0:	d19a      	bne.n	8000dd8 <HAL_RCC_ClockConfig+0x3c>
      return HAL_ERROR;
    }
  }    

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000ea2:	682a      	ldr	r2, [r5, #0]
 8000ea4:	4c11      	ldr	r4, [pc, #68]	; (8000eec <HAL_RCC_ClockConfig+0x150>)
 8000ea6:	0753      	lsls	r3, r2, #29
 8000ea8:	d505      	bpl.n	8000eb6 <HAL_RCC_ClockConfig+0x11a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8000eaa:	68e1      	ldr	r1, [r4, #12]
 8000eac:	4b11      	ldr	r3, [pc, #68]	; (8000ef4 <HAL_RCC_ClockConfig+0x158>)
 8000eae:	400b      	ands	r3, r1
 8000eb0:	68e9      	ldr	r1, [r5, #12]
 8000eb2:	430b      	orrs	r3, r1
 8000eb4:	60e3      	str	r3, [r4, #12]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000eb6:	0713      	lsls	r3, r2, #28
 8000eb8:	d506      	bpl.n	8000ec8 <HAL_RCC_ClockConfig+0x12c>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8000eba:	68e3      	ldr	r3, [r4, #12]
 8000ebc:	6929      	ldr	r1, [r5, #16]
 8000ebe:	4a0e      	ldr	r2, [pc, #56]	; (8000ef8 <HAL_RCC_ClockConfig+0x15c>)
 8000ec0:	00c9      	lsls	r1, r1, #3
 8000ec2:	4013      	ands	r3, r2
 8000ec4:	430b      	orrs	r3, r1
 8000ec6:	60e3      	str	r3, [r4, #12]
  }
 
  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8000ec8:	f7ff ff2c 	bl	8000d24 <HAL_RCC_GetSysClockFreq>
 8000ecc:	68e3      	ldr	r3, [r4, #12]
 8000ece:	4a0b      	ldr	r2, [pc, #44]	; (8000efc <HAL_RCC_ClockConfig+0x160>)
 8000ed0:	061b      	lsls	r3, r3, #24
 8000ed2:	0f1b      	lsrs	r3, r3, #28
 8000ed4:	5cd3      	ldrb	r3, [r2, r3]
 8000ed6:	40d8      	lsrs	r0, r3
 8000ed8:	4b09      	ldr	r3, [pc, #36]	; (8000f00 <HAL_RCC_ClockConfig+0x164>)
 8000eda:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8000edc:	2000      	movs	r0, #0
 8000ede:	f7ff fab3 	bl	8000448 <HAL_InitTick>
  
  return HAL_OK;
 8000ee2:	2000      	movs	r0, #0
}
 8000ee4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8000ee6:	46c0      	nop			; (mov r8, r8)
 8000ee8:	40022000 	.word	0x40022000
 8000eec:	40021000 	.word	0x40021000
 8000ef0:	00001388 	.word	0x00001388
 8000ef4:	fffff8ff 	.word	0xfffff8ff
 8000ef8:	ffffc7ff 	.word	0xffffc7ff
 8000efc:	08001cf1 	.word	0x08001cf1
 8000f00:	20000000 	.word	0x20000000

08000f04 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8000f04:	4b01      	ldr	r3, [pc, #4]	; (8000f0c <HAL_RCC_GetHCLKFreq+0x8>)
 8000f06:	6818      	ldr	r0, [r3, #0]
}
 8000f08:	4770      	bx	lr
 8000f0a:	46c0      	nop			; (mov r8, r8)
 8000f0c:	20000000 	.word	0x20000000

08000f10 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
 8000f10:	4b04      	ldr	r3, [pc, #16]	; (8000f24 <HAL_RCC_GetPCLK1Freq+0x14>)
 8000f12:	4a05      	ldr	r2, [pc, #20]	; (8000f28 <HAL_RCC_GetPCLK1Freq+0x18>)
 8000f14:	68db      	ldr	r3, [r3, #12]
 8000f16:	055b      	lsls	r3, r3, #21
 8000f18:	0f5b      	lsrs	r3, r3, #29
 8000f1a:	5cd3      	ldrb	r3, [r2, r3]
 8000f1c:	4a03      	ldr	r2, [pc, #12]	; (8000f2c <HAL_RCC_GetPCLK1Freq+0x1c>)
 8000f1e:	6810      	ldr	r0, [r2, #0]
 8000f20:	40d8      	lsrs	r0, r3
}    
 8000f22:	4770      	bx	lr
 8000f24:	40021000 	.word	0x40021000
 8000f28:	08001d01 	.word	0x08001d01
 8000f2c:	20000000 	.word	0x20000000

08000f30 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
 8000f30:	4b04      	ldr	r3, [pc, #16]	; (8000f44 <HAL_RCC_GetPCLK2Freq+0x14>)
 8000f32:	4a05      	ldr	r2, [pc, #20]	; (8000f48 <HAL_RCC_GetPCLK2Freq+0x18>)
 8000f34:	68db      	ldr	r3, [r3, #12]
 8000f36:	049b      	lsls	r3, r3, #18
 8000f38:	0f5b      	lsrs	r3, r3, #29
 8000f3a:	5cd3      	ldrb	r3, [r2, r3]
 8000f3c:	4a03      	ldr	r2, [pc, #12]	; (8000f4c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8000f3e:	6810      	ldr	r0, [r2, #0]
 8000f40:	40d8      	lsrs	r0, r3
} 
 8000f42:	4770      	bx	lr
 8000f44:	40021000 	.word	0x40021000
 8000f48:	08001d01 	.word	0x08001d01
 8000f4c:	20000000 	.word	0x20000000

08000f50 <HAL_RCCEx_PeriphCLKConfig>:
  
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*------------------------------- RTC/LCD Configuration ------------------------*/ 
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC) 
 8000f50:	6803      	ldr	r3, [r0, #0]
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8000f52:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000f54:	0004      	movs	r4, r0
  
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*------------------------------- RTC/LCD Configuration ------------------------*/ 
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC) 
 8000f56:	069b      	lsls	r3, r3, #26
 8000f58:	d57e      	bpl.n	8001058 <HAL_RCCEx_PeriphCLKConfig+0x108>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000f5a:	2280      	movs	r2, #128	; 0x80
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    }
#endif /* LCD */

    FlagStatus       pwrclkchanged = RESET;
 8000f5c:	2100      	movs	r1, #0

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000f5e:	4d5f      	ldr	r5, [pc, #380]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8000f60:	0552      	lsls	r2, r2, #21
 8000f62:	6bab      	ldr	r3, [r5, #56]	; 0x38
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    }
#endif /* LCD */

    FlagStatus       pwrclkchanged = RESET;
 8000f64:	9100      	str	r1, [sp, #0]

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000f66:	4213      	tst	r3, r2
 8000f68:	d104      	bne.n	8000f74 <HAL_RCCEx_PeriphCLKConfig+0x24>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000f6a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8000f6c:	4313      	orrs	r3, r2
 8000f6e:	63ab      	str	r3, [r5, #56]	; 0x38
      pwrclkchanged = SET;
 8000f70:	2301      	movs	r3, #1
 8000f72:	9300      	str	r3, [sp, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000f74:	2780      	movs	r7, #128	; 0x80
 8000f76:	4e5a      	ldr	r6, [pc, #360]	; (80010e0 <HAL_RCCEx_PeriphCLKConfig+0x190>)
 8000f78:	007f      	lsls	r7, r7, #1
 8000f7a:	6833      	ldr	r3, [r6, #0]
 8000f7c:	423b      	tst	r3, r7
 8000f7e:	d00a      	beq.n	8000f96 <HAL_RCCEx_PeriphCLKConfig+0x46>
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */ 
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 8000f80:	23c0      	movs	r3, #192	; 0xc0
 8000f82:	22c0      	movs	r2, #192	; 0xc0
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */ 
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 8000f84:	6828      	ldr	r0, [r5, #0]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 8000f86:	6861      	ldr	r1, [r4, #4]
 8000f88:	039b      	lsls	r3, r3, #14
 8000f8a:	4018      	ands	r0, r3
 8000f8c:	0292      	lsls	r2, r2, #10
 8000f8e:	400b      	ands	r3, r1
 8000f90:	4298      	cmp	r0, r3
 8000f92:	d111      	bne.n	8000fb8 <HAL_RCCEx_PeriphCLKConfig+0x68>
 8000f94:	e01a      	b.n	8000fcc <HAL_RCCEx_PeriphCLKConfig+0x7c>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000f96:	6833      	ldr	r3, [r6, #0]
 8000f98:	433b      	orrs	r3, r7
 8000f9a:	6033      	str	r3, [r6, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8000f9c:	f7ff fa80 	bl	80004a0 <HAL_GetTick>
 8000fa0:	9001      	str	r0, [sp, #4]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000fa2:	6833      	ldr	r3, [r6, #0]
 8000fa4:	423b      	tst	r3, r7
 8000fa6:	d1eb      	bne.n	8000f80 <HAL_RCCEx_PeriphCLKConfig+0x30>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000fa8:	f7ff fa7a 	bl	80004a0 <HAL_GetTick>
 8000fac:	9b01      	ldr	r3, [sp, #4]
 8000fae:	1ac0      	subs	r0, r0, r3
 8000fb0:	2864      	cmp	r0, #100	; 0x64
 8000fb2:	d9f6      	bls.n	8000fa2 <HAL_RCCEx_PeriphCLKConfig+0x52>
        {
          return HAL_TIMEOUT;
 8000fb4:	2003      	movs	r0, #3
 8000fb6:	e090      	b.n	80010da <HAL_RCCEx_PeriphCLKConfig+0x18a>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if (((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE) && HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8000fb8:	000b      	movs	r3, r1
 8000fba:	4013      	ands	r3, r2
 8000fbc:	4293      	cmp	r3, r2
 8000fbe:	d105      	bne.n	8000fcc <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8000fc0:	4b46      	ldr	r3, [pc, #280]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
      {
        /* To update HSE divider, first switch-OFF HSE clock oscillator*/
        return HAL_ERROR; 
 8000fc2:	2001      	movs	r0, #1
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if (((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE) && HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8000fc4:	681b      	ldr	r3, [r3, #0]
 8000fc6:	039b      	lsls	r3, r3, #14
 8000fc8:	d500      	bpl.n	8000fcc <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8000fca:	e086      	b.n	80010da <HAL_RCCEx_PeriphCLKConfig+0x18a>
        return HAL_ERROR; 
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 8000fcc:	6d28      	ldr	r0, [r5, #80]	; 0x50
 8000fce:	4b43      	ldr	r3, [pc, #268]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8000fd0:	4002      	ands	r2, r0
    
    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 8000fd2:	d110      	bne.n	8000ff6 <HAL_RCCEx_PeriphCLKConfig+0xa6>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8000fd4:	6863      	ldr	r3, [r4, #4]
 8000fd6:	22c0      	movs	r2, #192	; 0xc0
 8000fd8:	0018      	movs	r0, r3
 8000fda:	0292      	lsls	r2, r2, #10
 8000fdc:	4010      	ands	r0, r2
 8000fde:	4290      	cmp	r0, r2
 8000fe0:	d12f      	bne.n	8001042 <HAL_RCCEx_PeriphCLKConfig+0xf2>
 8000fe2:	682a      	ldr	r2, [r5, #0]
 8000fe4:	493f      	ldr	r1, [pc, #252]	; (80010e4 <HAL_RCCEx_PeriphCLKConfig+0x194>)
 8000fe6:	4011      	ands	r1, r2
 8000fe8:	22c0      	movs	r2, #192	; 0xc0
 8000fea:	0392      	lsls	r2, r2, #14
 8000fec:	401a      	ands	r2, r3
 8000fee:	000b      	movs	r3, r1
 8000ff0:	4313      	orrs	r3, r2
 8000ff2:	602b      	str	r3, [r5, #0]
 8000ff4:	e025      	b.n	8001042 <HAL_RCCEx_PeriphCLKConfig+0xf2>
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
    
    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 8000ff6:	20c0      	movs	r0, #192	; 0xc0
 8000ff8:	0280      	lsls	r0, r0, #10
 8000ffa:	4001      	ands	r1, r0
 8000ffc:	428a      	cmp	r2, r1
 8000ffe:	d0e9      	beq.n	8000fd4 <HAL_RCCEx_PeriphCLKConfig+0x84>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8001000:	6822      	ldr	r2, [r4, #0]
 8001002:	0692      	lsls	r2, r2, #26
 8001004:	d5e6      	bpl.n	8000fd4 <HAL_RCCEx_PeriphCLKConfig+0x84>
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
      
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8001006:	2680      	movs	r6, #128	; 0x80
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8001008:	6d18      	ldr	r0, [r3, #80]	; 0x50
      
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800100a:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800100c:	0336      	lsls	r6, r6, #12
 800100e:	4331      	orrs	r1, r6
 8001010:	6519      	str	r1, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 8001012:	6d1e      	ldr	r6, [r3, #80]	; 0x50
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8001014:	4a34      	ldr	r2, [pc, #208]	; (80010e8 <HAL_RCCEx_PeriphCLKConfig+0x198>)
      
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
      __HAL_RCC_BACKUPRESET_RELEASE();
 8001016:	4935      	ldr	r1, [pc, #212]	; (80010ec <HAL_RCCEx_PeriphCLKConfig+0x19c>)
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8001018:	4002      	ands	r2, r0
      
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
      __HAL_RCC_BACKUPRESET_RELEASE();
 800101a:	4031      	ands	r1, r6
 800101c:	6519      	str	r1, [r3, #80]	; 0x50
      
      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 800101e:	651a      	str	r2, [r3, #80]	; 0x50
      
       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 8001020:	05c3      	lsls	r3, r0, #23
 8001022:	d5d7      	bpl.n	8000fd4 <HAL_RCCEx_PeriphCLKConfig+0x84>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001024:	f7ff fa3c 	bl	80004a0 <HAL_GetTick>
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001028:	2780      	movs	r7, #128	; 0x80
      
       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800102a:	0006      	movs	r6, r0
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800102c:	00bf      	lsls	r7, r7, #2
 800102e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8001030:	423b      	tst	r3, r7
 8001032:	d1cf      	bne.n	8000fd4 <HAL_RCCEx_PeriphCLKConfig+0x84>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001034:	f7ff fa34 	bl	80004a0 <HAL_GetTick>
 8001038:	4b2d      	ldr	r3, [pc, #180]	; (80010f0 <HAL_RCCEx_PeriphCLKConfig+0x1a0>)
 800103a:	1b80      	subs	r0, r0, r6
 800103c:	4298      	cmp	r0, r3
 800103e:	d9f6      	bls.n	800102e <HAL_RCCEx_PeriphCLKConfig+0xde>
 8001040:	e7b8      	b.n	8000fb4 <HAL_RCCEx_PeriphCLKConfig+0x64>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001042:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8001044:	4a25      	ldr	r2, [pc, #148]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8001046:	4303      	orrs	r3, r0
 8001048:	652b      	str	r3, [r5, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800104a:	9b00      	ldr	r3, [sp, #0]
 800104c:	2b01      	cmp	r3, #1
 800104e:	d103      	bne.n	8001058 <HAL_RCCEx_PeriphCLKConfig+0x108>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001050:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8001052:	4b28      	ldr	r3, [pc, #160]	; (80010f4 <HAL_RCCEx_PeriphCLKConfig+0x1a4>)
 8001054:	400b      	ands	r3, r1
 8001056:	6393      	str	r3, [r2, #56]	; 0x38
    }
  }
  
#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001058:	6823      	ldr	r3, [r4, #0]
 800105a:	07da      	lsls	r2, r3, #31
 800105c:	d506      	bpl.n	800106c <HAL_RCCEx_PeriphCLKConfig+0x11c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800105e:	2003      	movs	r0, #3
 8001060:	491e      	ldr	r1, [pc, #120]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8001062:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 8001064:	4382      	bics	r2, r0
 8001066:	68a0      	ldr	r0, [r4, #8]
 8001068:	4302      	orrs	r2, r0
 800106a:	64ca      	str	r2, [r1, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */
  
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800106c:	079a      	lsls	r2, r3, #30
 800106e:	d506      	bpl.n	800107e <HAL_RCCEx_PeriphCLKConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001070:	200c      	movs	r0, #12
 8001072:	491a      	ldr	r1, [pc, #104]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8001074:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 8001076:	4382      	bics	r2, r0
 8001078:	68e0      	ldr	r0, [r4, #12]
 800107a:	4302      	orrs	r2, r0
 800107c:	64ca      	str	r2, [r1, #76]	; 0x4c
  }
  
  /*------------------------------ LPUART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800107e:	075a      	lsls	r2, r3, #29
 8001080:	d506      	bpl.n	8001090 <HAL_RCCEx_PeriphCLKConfig+0x140>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));
    
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8001082:	4916      	ldr	r1, [pc, #88]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8001084:	4a1c      	ldr	r2, [pc, #112]	; (80010f8 <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
 8001086:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
 8001088:	4002      	ands	r2, r0
 800108a:	6920      	ldr	r0, [r4, #16]
 800108c:	4302      	orrs	r2, r0
 800108e:	64ca      	str	r2, [r1, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001090:	071a      	lsls	r2, r3, #28
 8001092:	d506      	bpl.n	80010a2 <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001094:	4911      	ldr	r1, [pc, #68]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 8001096:	4a19      	ldr	r2, [pc, #100]	; (80010fc <HAL_RCCEx_PeriphCLKConfig+0x1ac>)
 8001098:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
 800109a:	4002      	ands	r2, r0
 800109c:	6960      	ldr	r0, [r4, #20]
 800109e:	4302      	orrs	r2, r0
 80010a0:	64ca      	str	r2, [r1, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80010a2:	05da      	lsls	r2, r3, #23
 80010a4:	d506      	bpl.n	80010b4 <HAL_RCCEx_PeriphCLKConfig+0x164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80010a6:	490d      	ldr	r1, [pc, #52]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 80010a8:	4a0f      	ldr	r2, [pc, #60]	; (80010e8 <HAL_RCCEx_PeriphCLKConfig+0x198>)
 80010aa:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
 80010ac:	4002      	ands	r2, r0
 80010ae:	69a0      	ldr	r0, [r4, #24]
 80010b0:	4302      	orrs	r2, r0
 80010b2:	64ca      	str	r2, [r1, #76]	; 0x4c
  }  
#endif /* RCC_CCIPR_I2C3SEL */

#if defined(USB)
 /*---------------------------- USB and RNG configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 80010b4:	065a      	lsls	r2, r3, #25
 80010b6:	d506      	bpl.n	80010c6 <HAL_RCCEx_PeriphCLKConfig+0x176>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80010b8:	4908      	ldr	r1, [pc, #32]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 80010ba:	4a11      	ldr	r2, [pc, #68]	; (8001100 <HAL_RCCEx_PeriphCLKConfig+0x1b0>)
 80010bc:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
 80010be:	4002      	ands	r2, r0
 80010c0:	6a20      	ldr	r0, [r4, #32]
 80010c2:	4302      	orrs	r2, r0
 80010c4:	64ca      	str	r2, [r1, #76]	; 0x4c
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
  }

  return HAL_OK;
 80010c6:	2000      	movs	r0, #0
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* USB */
  
  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80010c8:	061b      	lsls	r3, r3, #24
 80010ca:	d506      	bpl.n	80010da <HAL_RCCEx_PeriphCLKConfig+0x18a>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 80010cc:	4903      	ldr	r1, [pc, #12]	; (80010dc <HAL_RCCEx_PeriphCLKConfig+0x18c>)
 80010ce:	4b0d      	ldr	r3, [pc, #52]	; (8001104 <HAL_RCCEx_PeriphCLKConfig+0x1b4>)
 80010d0:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 80010d2:	4013      	ands	r3, r2
 80010d4:	69e2      	ldr	r2, [r4, #28]
 80010d6:	4313      	orrs	r3, r2
 80010d8:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  return HAL_OK;
}
 80010da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80010dc:	40021000 	.word	0x40021000
 80010e0:	40007000 	.word	0x40007000
 80010e4:	ffcfffff 	.word	0xffcfffff
 80010e8:	fffcffff 	.word	0xfffcffff
 80010ec:	fff7ffff 	.word	0xfff7ffff
 80010f0:	00001388 	.word	0x00001388
 80010f4:	efffffff 	.word	0xefffffff
 80010f8:	fffff3ff 	.word	0xfffff3ff
 80010fc:	ffffcfff 	.word	0xffffcfff
 8001100:	fbffffff 	.word	0xfbffffff
 8001104:	fff3ffff 	.word	0xfff3ffff

08001108 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_I2C3     I2C3 peripheral clock (*)
  * @note   (*) means that this peripheral is not present on all the devices
  * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8001108:	b510      	push	{r4, lr}
#endif /* USB */

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
  
  switch (PeriphClk)
 800110a:	2808      	cmp	r0, #8
 800110c:	d100      	bne.n	8001110 <HAL_RCCEx_GetPeriphCLKFreq+0x8>
 800110e:	e0b2      	b.n	8001276 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
 8001110:	d809      	bhi.n	8001126 <HAL_RCCEx_GetPeriphCLKFreq+0x1e>
 8001112:	2802      	cmp	r0, #2
 8001114:	d100      	bne.n	8001118 <HAL_RCCEx_GetPeriphCLKFreq+0x10>
 8001116:	e089      	b.n	800122c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
 8001118:	2804      	cmp	r0, #4
 800111a:	d100      	bne.n	800111e <HAL_RCCEx_GetPeriphCLKFreq+0x16>
 800111c:	e096      	b.n	800124c <HAL_RCCEx_GetPeriphCLKFreq+0x144>
 800111e:	2801      	cmp	r0, #1
 8001120:	d000      	beq.n	8001124 <HAL_RCCEx_GetPeriphCLKFreq+0x1c>
 8001122:	e0d1      	b.n	80012c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1c0>
 8001124:	e06b      	b.n	80011fe <HAL_RCCEx_GetPeriphCLKFreq+0xf6>
 8001126:	2820      	cmp	r0, #32
 8001128:	d00c      	beq.n	8001144 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
 800112a:	d803      	bhi.n	8001134 <HAL_RCCEx_GetPeriphCLKFreq+0x2c>
 800112c:	2810      	cmp	r0, #16
 800112e:	d100      	bne.n	8001132 <HAL_RCCEx_GetPeriphCLKFreq+0x2a>
 8001130:	e0ae      	b.n	8001290 <HAL_RCCEx_GetPeriphCLKFreq+0x188>
 8001132:	e0c9      	b.n	80012c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1c0>
 8001134:	2840      	cmp	r0, #64	; 0x40
 8001136:	d037      	beq.n	80011a8 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 8001138:	2380      	movs	r3, #128	; 0x80
 800113a:	005b      	lsls	r3, r3, #1
 800113c:	4298      	cmp	r0, r3
 800113e:	d100      	bne.n	8001142 <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 8001140:	e0ad      	b.n	800129e <HAL_RCCEx_GetPeriphCLKFreq+0x196>
 8001142:	e0c1      	b.n	80012c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1c0>
    {
      /* Get RCC CSR configuration ------------------------------------------------------*/
      temp_reg = RCC->CSR;

      /* Get the current RTC source */
      srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8001144:	24c0      	movs	r4, #192	; 0xc0

      /* Check if LSE is ready if RTC clock selection is LSE */
      if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
 8001146:	2180      	movs	r1, #128	; 0x80
#if defined(LCD)
  case RCC_PERIPHCLK_LCD:
#endif /* LCD */
    {
      /* Get RCC CSR configuration ------------------------------------------------------*/
      temp_reg = RCC->CSR;
 8001148:	4a61      	ldr	r2, [pc, #388]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)

      /* Get the current RTC source */
      srcclk = __HAL_RCC_GET_RTC_SOURCE();
 800114a:	02a4      	lsls	r4, r4, #10
#if defined(LCD)
  case RCC_PERIPHCLK_LCD:
#endif /* LCD */
    {
      /* Get RCC CSR configuration ------------------------------------------------------*/
      temp_reg = RCC->CSR;
 800114c:	6d10      	ldr	r0, [r2, #80]	; 0x50

      /* Get the current RTC source */
      srcclk = __HAL_RCC_GET_RTC_SOURCE();
 800114e:	6d13      	ldr	r3, [r2, #80]	; 0x50

      /* Check if LSE is ready if RTC clock selection is LSE */
      if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
 8001150:	0249      	lsls	r1, r1, #9
    {
      /* Get RCC CSR configuration ------------------------------------------------------*/
      temp_reg = RCC->CSR;

      /* Get the current RTC source */
      srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8001152:	4023      	ands	r3, r4

      /* Check if LSE is ready if RTC clock selection is LSE */
      if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
 8001154:	428b      	cmp	r3, r1
 8001156:	d065      	beq.n	8001224 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>
      {
        frequency = LSE_VALUE;
      }
      /* Check if LSI is ready if RTC clock selection is LSI */
      else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSIRDY)))
 8001158:	2180      	movs	r1, #128	; 0x80
 800115a:	0289      	lsls	r1, r1, #10
 800115c:	428b      	cmp	r3, r1
 800115e:	d106      	bne.n	800116e <HAL_RCCEx_GetPeriphCLKFreq+0x66>
 8001160:	2302      	movs	r3, #2
 8001162:	4003      	ands	r3, r0
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 8001164:	1e18      	subs	r0, r3, #0
      if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
      {
        frequency = LSE_VALUE;
      }
      /* Check if LSI is ready if RTC clock selection is LSI */
      else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSIRDY)))
 8001166:	d100      	bne.n	800116a <HAL_RCCEx_GetPeriphCLKFreq+0x62>
 8001168:	e0b1      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
      {
        frequency = LSI_VALUE;
 800116a:	485a      	ldr	r0, [pc, #360]	; (80012d4 <HAL_RCCEx_GetPeriphCLKFreq+0x1cc>)
 800116c:	e0af      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 800116e:	2000      	movs	r0, #0
      else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSIRDY)))
      {
        frequency = LSI_VALUE;
      }
      /* Check if HSE is ready and if RTC clock selection is HSE */
      else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIVX) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 8001170:	42a3      	cmp	r3, r4
 8001172:	d000      	beq.n	8001176 <HAL_RCCEx_GetPeriphCLKFreq+0x6e>
 8001174:	e0ab      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
 8001176:	6813      	ldr	r3, [r2, #0]
 8001178:	420b      	tst	r3, r1
 800117a:	d100      	bne.n	800117e <HAL_RCCEx_GetPeriphCLKFreq+0x76>
 800117c:	e0a7      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
      {
        /* Get the current HSE clock divider */
        clkprediv = __HAL_RCC_GET_RTC_HSE_PRESCALER();
 800117e:	6813      	ldr	r3, [r2, #0]

        switch (clkprediv)
 8001180:	22c0      	movs	r2, #192	; 0xc0
 8001182:	2180      	movs	r1, #128	; 0x80
 8001184:	0392      	lsls	r2, r2, #14
 8001186:	4013      	ands	r3, r2
 8001188:	0389      	lsls	r1, r1, #14
 800118a:	428b      	cmp	r3, r1
 800118c:	d008      	beq.n	80011a0 <HAL_RCCEx_GetPeriphCLKFreq+0x98>
 800118e:	4293      	cmp	r3, r2
 8001190:	d100      	bne.n	8001194 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
 8001192:	e09b      	b.n	80012cc <HAL_RCCEx_GetPeriphCLKFreq+0x1c4>
 8001194:	2280      	movs	r2, #128	; 0x80
 8001196:	0352      	lsls	r2, r2, #13
 8001198:	4293      	cmp	r3, r2
 800119a:	d103      	bne.n	80011a4 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
            frequency = HSE_VALUE / 8U;
            break;
          }
          case RCC_RTC_HSE_DIV_4:   /* HSE DIV4 has been selected  */
          {
            frequency = HSE_VALUE / 4U;
 800119c:	484e      	ldr	r0, [pc, #312]	; (80012d8 <HAL_RCCEx_GetPeriphCLKFreq+0x1d0>)
            break;
 800119e:	e096      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
            frequency = HSE_VALUE / 16U;
            break;
          }
          case RCC_RTC_HSE_DIV_8:   /* HSE DIV8 has been selected  */
          {
            frequency = HSE_VALUE / 8U;
 80011a0:	484e      	ldr	r0, [pc, #312]	; (80012dc <HAL_RCCEx_GetPeriphCLKFreq+0x1d4>)
 80011a2:	e094      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
            frequency = HSE_VALUE / 4U;
            break;
          }
          default:                  /* HSE DIV2 has been selected  */
          {
            frequency = HSE_VALUE / 2U;
 80011a4:	484e      	ldr	r0, [pc, #312]	; (80012e0 <HAL_RCCEx_GetPeriphCLKFreq+0x1d8>)
            break;
 80011a6:	e092      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
    }
#if defined(USB)
   case RCC_PERIPHCLK_USB:
    {  
        /* Get the current USB source */
        srcclk = __HAL_RCC_GET_USB_SOURCE();
 80011a8:	2180      	movs	r1, #128	; 0x80
 80011aa:	4b49      	ldr	r3, [pc, #292]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 80011ac:	04c9      	lsls	r1, r1, #19
 80011ae:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80011b0:	400a      	ands	r2, r1
        
        if((srcclk == RCC_USBCLKSOURCE_PLL) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY)))
 80011b2:	d11c      	bne.n	80011ee <HAL_RCCEx_GetPeriphCLKFreq+0xe6>
 80011b4:	6819      	ldr	r1, [r3, #0]
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 80011b6:	0010      	movs	r0, r2
   case RCC_PERIPHCLK_USB:
    {  
        /* Get the current USB source */
        srcclk = __HAL_RCC_GET_USB_SOURCE();
        
        if((srcclk == RCC_USBCLKSOURCE_PLL) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY)))
 80011b8:	018a      	lsls	r2, r1, #6
 80011ba:	d400      	bmi.n	80011be <HAL_RCCEx_GetPeriphCLKFreq+0xb6>
 80011bc:	e087      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
        {
            /* Get PLL clock source and multiplication factor ----------------------*/
            pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
 80011be:	68da      	ldr	r2, [r3, #12]
            plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
            pllmul = PLLMulTable[(pllmul >> RCC_CFGR_PLLMUL_Pos)];
 80011c0:	4848      	ldr	r0, [pc, #288]	; (80012e4 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>)
        
        if((srcclk == RCC_USBCLKSOURCE_PLL) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY)))
        {
            /* Get PLL clock source and multiplication factor ----------------------*/
            pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
            plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
 80011c2:	68d9      	ldr	r1, [r3, #12]
            pllmul = PLLMulTable[(pllmul >> RCC_CFGR_PLLMUL_Pos)];
 80011c4:	0292      	lsls	r2, r2, #10
 80011c6:	0f12      	lsrs	r2, r2, #28
 80011c8:	5c82      	ldrb	r2, [r0, r2]
            plldiv = (plldiv >> RCC_CFGR_PLLDIV_Pos) + 1U;   
 80011ca:	0209      	lsls	r1, r1, #8
            
            /* Compute PLL clock input */
            if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)
 80011cc:	68d8      	ldr	r0, [r3, #12]
        {
            /* Get PLL clock source and multiplication factor ----------------------*/
            pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
            plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
            pllmul = PLLMulTable[(pllmul >> RCC_CFGR_PLLMUL_Pos)];
            plldiv = (plldiv >> RCC_CFGR_PLLDIV_Pos) + 1U;   
 80011ce:	0f89      	lsrs	r1, r1, #30
 80011d0:	3101      	adds	r1, #1
            
            /* Compute PLL clock input */
            if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)
 80011d2:	03c0      	lsls	r0, r0, #15
 80011d4:	d404      	bmi.n	80011e0 <HAL_RCCEx_GetPeriphCLKFreq+0xd8>
            {
                if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
 80011d6:	681b      	ldr	r3, [r3, #0]
 80011d8:	06db      	lsls	r3, r3, #27
 80011da:	d403      	bmi.n	80011e4 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>
                {
                    pllvco =  (HSI_VALUE >> 2U);
                }
                else 
                {
                    pllvco =  HSI_VALUE;
 80011dc:	4842      	ldr	r0, [pc, #264]	; (80012e8 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>)
 80011de:	e002      	b.n	80011e6 <HAL_RCCEx_GetPeriphCLKFreq+0xde>
                }
            }
            else /* HSE source */
            {
                pllvco = HSE_VALUE;
 80011e0:	4842      	ldr	r0, [pc, #264]	; (80012ec <HAL_RCCEx_GetPeriphCLKFreq+0x1e4>)
 80011e2:	e000      	b.n	80011e6 <HAL_RCCEx_GetPeriphCLKFreq+0xde>
            /* Compute PLL clock input */
            if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)
            {
                if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
                {
                    pllvco =  (HSI_VALUE >> 2U);
 80011e4:	483e      	ldr	r0, [pc, #248]	; (80012e0 <HAL_RCCEx_GetPeriphCLKFreq+0x1d8>)
            {
                pllvco = HSE_VALUE;
            }
            /* pllvco * pllmul / plldiv */
            pllvco = (pllvco * pllmul);
            frequency = (pllvco/ plldiv);
 80011e6:	4350      	muls	r0, r2
 80011e8:	f7fe ff98 	bl	800011c <__aeabi_uidiv>
 80011ec:	e06f      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 80011ee:	2000      	movs	r0, #0
            /* pllvco * pllmul / plldiv */
            pllvco = (pllvco * pllmul);
            frequency = (pllvco/ plldiv);
            
        }
        else if((srcclk == RCC_USBCLKSOURCE_HSI48) && (HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)))
 80011f0:	428a      	cmp	r2, r1
 80011f2:	d16c      	bne.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
 80011f4:	689b      	ldr	r3, [r3, #8]
 80011f6:	079b      	lsls	r3, r3, #30
 80011f8:	d569      	bpl.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
        {
            frequency = HSI48_VALUE;
 80011fa:	483d      	ldr	r0, [pc, #244]	; (80012f0 <HAL_RCCEx_GetPeriphCLKFreq+0x1e8>)
 80011fc:	e067      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
#endif /* USB */
#if defined(RCC_CCIPR_USART1SEL)
  case RCC_PERIPHCLK_USART1:
    {
      /* Get the current USART1 source */
      srcclk = __HAL_RCC_GET_USART1_SOURCE();
 80011fe:	2303      	movs	r3, #3
 8001200:	4a33      	ldr	r2, [pc, #204]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 8001202:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8001204:	400b      	ands	r3, r1

      /* Check if USART1 clock selection is PCLK2 */
      if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 8001206:	d102      	bne.n	800120e <HAL_RCCEx_GetPeriphCLKFreq+0x106>
      {
        frequency = HAL_RCC_GetPCLK2Freq();
 8001208:	f7ff fe92 	bl	8000f30 <HAL_RCC_GetPCLK2Freq>
 800120c:	e05f      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
      }
      /* Check if HSI is ready and if USART1 clock selection is HSI */
      else if ((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 800120e:	2b02      	cmp	r3, #2
 8001210:	d04f      	beq.n	80012b2 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
      {
        frequency = HSI_VALUE;
      }
      /* Check if USART1 clock selection is SYSCLK */
      else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 8001212:	2b01      	cmp	r3, #1
 8001214:	d102      	bne.n	800121c <HAL_RCCEx_GetPeriphCLKFreq+0x114>
      {
        frequency = HAL_RCC_GetSysClockFreq();
 8001216:	f7ff fd85 	bl	8000d24 <HAL_RCC_GetSysClockFreq>
 800121a:	e058      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 800121c:	2000      	movs	r0, #0
      else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      /* Check if LSE is ready  and if USART1 clock selection is LSE */
      else if ((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSERDY)))
 800121e:	2b03      	cmp	r3, #3
 8001220:	d155      	bne.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
 8001222:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8001224:	0580      	lsls	r0, r0, #22
      srcclk = __HAL_RCC_GET_RTC_SOURCE();

      /* Check if LSE is ready if RTC clock selection is LSE */
      if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
      {
        frequency = LSE_VALUE;
 8001226:	0fc0      	lsrs	r0, r0, #31
 8001228:	03c0      	lsls	r0, r0, #15
 800122a:	e050      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
    }
#endif /* RCC_CCIPR_USART1SEL */
  case RCC_PERIPHCLK_USART2:
    {
      /* Get the current USART2 source */
      srcclk = __HAL_RCC_GET_USART2_SOURCE();
 800122c:	230c      	movs	r3, #12
 800122e:	4a28      	ldr	r2, [pc, #160]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 8001230:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8001232:	400b      	ands	r3, r1

      /* Check if USART2 clock selection is PCLK1 */
      if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
 8001234:	d102      	bne.n	800123c <HAL_RCCEx_GetPeriphCLKFreq+0x134>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
 8001236:	f7ff fe6b 	bl	8000f10 <HAL_RCC_GetPCLK1Freq>
 800123a:	e048      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
      }
      /* Check if HSI is ready and if USART2 clock selection is HSI */
      else if ((srcclk == RCC_USART2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 800123c:	2b08      	cmp	r3, #8
 800123e:	d038      	beq.n	80012b2 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
      {
        frequency = HSI_VALUE;
      }
      /* Check if USART2 clock selection is SYSCLK */
      else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
 8001240:	2b04      	cmp	r3, #4
 8001242:	d0e8      	beq.n	8001216 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 8001244:	2000      	movs	r0, #0
      else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      /* Check if LSE is ready  and if USART2 clock selection is LSE */
      else if ((srcclk == RCC_USART2CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSERDY)))
 8001246:	2b0c      	cmp	r3, #12
 8001248:	d141      	bne.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
 800124a:	e7ea      	b.n	8001222 <HAL_RCCEx_GetPeriphCLKFreq+0x11a>
      break;
    }
  case RCC_PERIPHCLK_LPUART1:
    {
      /* Get the current LPUART1 source */
      srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 800124c:	21c0      	movs	r1, #192	; 0xc0
 800124e:	4a20      	ldr	r2, [pc, #128]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 8001250:	0109      	lsls	r1, r1, #4
 8001252:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8001254:	400b      	ands	r3, r1

      /* Check if LPUART1 clock selection is PCLK1 */
      if (srcclk == RCC_LPUART1CLKSOURCE_PCLK1)
 8001256:	d0ee      	beq.n	8001236 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      /* Check if HSI is ready and if LPUART1 clock selection is HSI */
      else if ((srcclk == RCC_LPUART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 8001258:	2480      	movs	r4, #128	; 0x80
 800125a:	0124      	lsls	r4, r4, #4
 800125c:	42a3      	cmp	r3, r4
 800125e:	d102      	bne.n	8001266 <HAL_RCCEx_GetPeriphCLKFreq+0x15e>
 8001260:	6813      	ldr	r3, [r2, #0]
 8001262:	4003      	ands	r3, r0
 8001264:	e028      	b.n	80012b8 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>
      {
        frequency = HSI_VALUE;
      }
      /* Check if LPUART1 clock selection is SYSCLK */
      else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 8001266:	2080      	movs	r0, #128	; 0x80
 8001268:	00c0      	lsls	r0, r0, #3
 800126a:	4283      	cmp	r3, r0
 800126c:	d0d3      	beq.n	8001216 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 800126e:	2000      	movs	r0, #0
      else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
      {
        frequency = HAL_RCC_GetSysClockFreq();
      }
      /* Check if LSE is ready  and if LPUART1 clock selection is LSE */
      else if ((srcclk == RCC_LPUART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSERDY)))
 8001270:	428b      	cmp	r3, r1
 8001272:	d12c      	bne.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
 8001274:	e7d5      	b.n	8001222 <HAL_RCCEx_GetPeriphCLKFreq+0x11a>
      break;
    }    
  case RCC_PERIPHCLK_I2C1:
    {
      /* Get the current I2C1 source */
      srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 8001276:	23c0      	movs	r3, #192	; 0xc0
 8001278:	4a15      	ldr	r2, [pc, #84]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 800127a:	019b      	lsls	r3, r3, #6
 800127c:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800127e:	400b      	ands	r3, r1

      /* Check if I2C1 clock selection is PCLK1 */
      if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 8001280:	d0d9      	beq.n	8001236 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      /* Check if HSI is ready and if I2C1 clock selection is HSI */
      else if ((srcclk == RCC_I2C1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 8001282:	2180      	movs	r1, #128	; 0x80
 8001284:	0189      	lsls	r1, r1, #6
 8001286:	428b      	cmp	r3, r1
 8001288:	d013      	beq.n	80012b2 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
      {
        frequency = HSI_VALUE;
      }
      /* Check if I2C1 clock selection is SYSCLK */
      else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 800128a:	2280      	movs	r2, #128	; 0x80
 800128c:	0152      	lsls	r2, r2, #5
 800128e:	e019      	b.n	80012c4 <HAL_RCCEx_GetPeriphCLKFreq+0x1bc>
#if defined(I2C2)
  case RCC_PERIPHCLK_I2C2:
    {

      /* Check if I2C2 on APB1 clock enabled*/
      if (READ_BIT(RCC->APB1ENR, (RCC_APB1ENR_I2C2EN))==RCC_APB1ENR_I2C2EN)
 8001290:	4b0f      	ldr	r3, [pc, #60]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 8001292:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8001294:	2380      	movs	r3, #128	; 0x80
 8001296:	03db      	lsls	r3, r3, #15
 8001298:	4018      	ands	r0, r3
 800129a:	d018      	beq.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
 800129c:	e7cb      	b.n	8001236 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>

#if defined(RCC_CCIPR_I2C3SEL)
  case RCC_PERIPHCLK_I2C3:
    {
      /* Get the current I2C1 source */
      srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 800129e:	23c0      	movs	r3, #192	; 0xc0
 80012a0:	4a0b      	ldr	r2, [pc, #44]	; (80012d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>)
 80012a2:	029b      	lsls	r3, r3, #10
 80012a4:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 80012a6:	400b      	ands	r3, r1

      /* Check if I2C3 clock selection is PCLK1 */
      if (srcclk == RCC_I2C3CLKSOURCE_PCLK1)
 80012a8:	d0c5      	beq.n	8001236 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      /* Check if HSI is ready and if I2C3 clock selection is HSI */
      else if ((srcclk == RCC_I2C3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80012aa:	2180      	movs	r1, #128	; 0x80
 80012ac:	0289      	lsls	r1, r1, #10
 80012ae:	428b      	cmp	r3, r1
 80012b0:	d106      	bne.n	80012c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1b8>
 80012b2:	2304      	movs	r3, #4
 80012b4:	6812      	ldr	r2, [r2, #0]
 80012b6:	4013      	ands	r3, r2
        {
            frequency = HSI48_VALUE;
        }
        else /* RCC_USBCLKSOURCE_NONE */
        {
            frequency = 0U;
 80012b8:	1e18      	subs	r0, r3, #0
      if (srcclk == RCC_I2C3CLKSOURCE_PCLK1)
      {
        frequency = HAL_RCC_GetPCLK1Freq();
      }
      /* Check if HSI is ready and if I2C3 clock selection is HSI */
      else if ((srcclk == RCC_I2C3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
 80012ba:	d008      	beq.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
        frequency = HAL_RCC_GetPCLK2Freq();
      }
      /* Check if HSI is ready and if USART1 clock selection is HSI */
      else if ((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
      {
        frequency = HSI_VALUE;
 80012bc:	480a      	ldr	r0, [pc, #40]	; (80012e8 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>)
 80012be:	e006      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>
      else if ((srcclk == RCC_I2C3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
      {
        frequency = HSI_VALUE;
      }
      /* Check if I2C3 clock selection is SYSCLK */
      else if (srcclk == RCC_I2C3CLKSOURCE_SYSCLK)
 80012c0:	2280      	movs	r2, #128	; 0x80
 80012c2:	0252      	lsls	r2, r2, #9
 80012c4:	4293      	cmp	r3, r2
 80012c6:	d0a6      	beq.n	8001216 <HAL_RCCEx_GetPeriphCLKFreq+0x10e>
  * @note   (*) means that this peripheral is not present on all the devices
  * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
  uint32_t temp_reg = 0U, clkprediv = 0U, frequency = 0U;
 80012c8:	2000      	movs	r0, #0
 80012ca:	e000      	b.n	80012ce <HAL_RCCEx_GetPeriphCLKFreq+0x1c6>

        switch (clkprediv)
        {
          case RCC_RTC_HSE_DIV_16:  /* HSE DIV16 has been selected */
          {
            frequency = HSE_VALUE / 16U;
 80012cc:	4809      	ldr	r0, [pc, #36]	; (80012f4 <HAL_RCCEx_GetPeriphCLKFreq+0x1ec>)
    {
      break;
    }
  }
  return(frequency);
}
 80012ce:	bd10      	pop	{r4, pc}
 80012d0:	40021000 	.word	0x40021000
 80012d4:	00009088 	.word	0x00009088
 80012d8:	001e8480 	.word	0x001e8480
 80012dc:	000f4240 	.word	0x000f4240
 80012e0:	003d0900 	.word	0x003d0900
 80012e4:	08001d09 	.word	0x08001d09
 80012e8:	00f42400 	.word	0x00f42400
 80012ec:	007a1200 	.word	0x007a1200
 80012f0:	02dc6c00 	.word	0x02dc6c00
 80012f4:	0007a120 	.word	0x0007a120

080012f8 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80012f8:	6803      	ldr	r3, [r0, #0]
 80012fa:	4a06      	ldr	r2, [pc, #24]	; (8001314 <UART_EndRxTransfer+0x1c>)
 80012fc:	6819      	ldr	r1, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80012fe:	306a      	adds	r0, #106	; 0x6a
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001300:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001302:	2101      	movs	r1, #1
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001304:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001306:	689a      	ldr	r2, [r3, #8]
 8001308:	438a      	bics	r2, r1
 800130a:	609a      	str	r2, [r3, #8]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800130c:	2320      	movs	r3, #32
 800130e:	7003      	strb	r3, [r0, #0]
}
 8001310:	4770      	bx	lr
 8001312:	46c0      	nop			; (mov r8, r8)
 8001314:	fffffedf 	.word	0xfffffedf

08001318 <HAL_UART_TxCpltCallback>:
 8001318:	4770      	bx	lr

0800131a <HAL_UART_RxCpltCallback>:
 800131a:	4770      	bx	lr

0800131c <UART_Receive_IT>:
  uint16_t* tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
 800131c:	0002      	movs	r2, r0
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param  huart UART handle.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 800131e:	b570      	push	{r4, r5, r6, lr}
  uint16_t* tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
 8001320:	326a      	adds	r2, #106	; 0x6a
 8001322:	7811      	ldrb	r1, [r2, #0]
 8001324:	6803      	ldr	r3, [r0, #0]
 8001326:	2922      	cmp	r1, #34	; 0x22
 8001328:	d12b      	bne.n	8001382 <UART_Receive_IT+0x66>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint16_t  uhMask = huart->Mask;
 800132a:	0001      	movs	r1, r0
 800132c:	315c      	adds	r1, #92	; 0x5c
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800132e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint16_t  uhMask = huart->Mask;
 8001330:	8809      	ldrh	r1, [r1, #0]

  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX)
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001332:	6885      	ldr	r5, [r0, #8]
 8001334:	4021      	ands	r1, r4
 8001336:	2480      	movs	r4, #128	; 0x80
 8001338:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800133a:	0164      	lsls	r4, r4, #5
 800133c:	42a5      	cmp	r5, r4
 800133e:	d106      	bne.n	800134e <UART_Receive_IT+0x32>
 8001340:	6904      	ldr	r4, [r0, #16]
 8001342:	2c00      	cmp	r4, #0
 8001344:	d103      	bne.n	800134e <UART_Receive_IT+0x32>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr ;
      *tmp = (uint16_t)(uhdata & uhMask);
 8001346:	8019      	strh	r1, [r3, #0]
      huart->pRxBuffPtr +=2;
 8001348:	3302      	adds	r3, #2
 800134a:	6543      	str	r3, [r0, #84]	; 0x54
 800134c:	e002      	b.n	8001354 <UART_Receive_IT+0x38>
    }
    else
    {
      *huart->pRxBuffPtr++ = (uint8_t)(uhdata & (uint8_t)uhMask);
 800134e:	1c5c      	adds	r4, r3, #1
 8001350:	6544      	str	r4, [r0, #84]	; 0x54
 8001352:	7019      	strb	r1, [r3, #0]
    }

    if(--huart->RxXferCount == 0U)
 8001354:	0001      	movs	r1, r0
      HAL_UART_RxCpltCallback(huart);

      return HAL_OK;
    }

    return HAL_OK;
 8001356:	2400      	movs	r4, #0
    else
    {
      *huart->pRxBuffPtr++ = (uint8_t)(uhdata & (uint8_t)uhMask);
    }

    if(--huart->RxXferCount == 0U)
 8001358:	315a      	adds	r1, #90	; 0x5a
 800135a:	880b      	ldrh	r3, [r1, #0]
 800135c:	3b01      	subs	r3, #1
 800135e:	b29b      	uxth	r3, r3
 8001360:	800b      	strh	r3, [r1, #0]
 8001362:	42a3      	cmp	r3, r4
 8001364:	d112      	bne.n	800138c <UART_Receive_IT+0x70>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001366:	6803      	ldr	r3, [r0, #0]
 8001368:	4909      	ldr	r1, [pc, #36]	; (8001390 <UART_Receive_IT+0x74>)
 800136a:	681d      	ldr	r5, [r3, #0]
 800136c:	4029      	ands	r1, r5

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800136e:	2501      	movs	r5, #1
    }

    if(--huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001370:	6019      	str	r1, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001372:	6899      	ldr	r1, [r3, #8]
 8001374:	43a9      	bics	r1, r5
 8001376:	6099      	str	r1, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8001378:	2320      	movs	r3, #32
 800137a:	7013      	strb	r3, [r2, #0]

      HAL_UART_RxCpltCallback(huart);
 800137c:	f7ff ffcd 	bl	800131a <HAL_UART_RxCpltCallback>
 8001380:	e004      	b.n	800138c <UART_Receive_IT+0x70>
    return HAL_OK;
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8001382:	2108      	movs	r1, #8

    return HAL_BUSY;
 8001384:	2402      	movs	r4, #2
    return HAL_OK;
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8001386:	699a      	ldr	r2, [r3, #24]
 8001388:	430a      	orrs	r2, r1
 800138a:	619a      	str	r2, [r3, #24]

    return HAL_BUSY;
  }
}
 800138c:	0020      	movs	r0, r4
 800138e:	bd70      	pop	{r4, r5, r6, pc}
 8001390:	fffffedf 	.word	0xfffffedf

08001394 <HAL_UART_ErrorCallback>:
 8001394:	4770      	bx	lr
	...

08001398 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart: UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001398:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800139a:	6803      	ldr	r3, [r0, #0]
  * @brief Handle UART interrupt request.
  * @param huart: UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 800139c:	0004      	movs	r4, r0
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
  uint32_t cr3its;
  uint32_t errorflags;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
 800139e:	200f      	movs	r0, #15
  * @param huart: UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 80013a0:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 80013a2:	6819      	ldr	r1, [r3, #0]
  uint32_t cr3its;
  uint32_t errorflags;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
 80013a4:	4010      	ands	r0, r2
  if (errorflags == RESET)
 80013a6:	d108      	bne.n	80013ba <HAL_UART_IRQHandler+0x22>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 80013a8:	2520      	movs	r5, #32
 80013aa:	422a      	tst	r2, r5
 80013ac:	d005      	beq.n	80013ba <HAL_UART_IRQHandler+0x22>
 80013ae:	4229      	tst	r1, r5
 80013b0:	d003      	beq.n	80013ba <HAL_UART_IRQHandler+0x22>
    {
      UART_Receive_IT(huart);
 80013b2:	0020      	movs	r0, r4
 80013b4:	f7ff ffb2 	bl	800131c <UART_Receive_IT>
      return;
 80013b8:	e0b5      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
    }
  }  

  /* If some errors occur */
  cr3its = READ_REG(huart->Instance->CR3);
 80013ba:	689e      	ldr	r6, [r3, #8]
  if(   (errorflags != RESET)
 80013bc:	2800      	cmp	r0, #0
 80013be:	d063      	beq.n	8001488 <HAL_UART_IRQHandler+0xf0>
     && (   ((cr3its & USART_CR3_EIE) != RESET)
 80013c0:	2501      	movs	r5, #1
 80013c2:	0030      	movs	r0, r6
 80013c4:	4028      	ands	r0, r5
 80013c6:	d103      	bne.n	80013d0 <HAL_UART_IRQHandler+0x38>
         || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
 80013c8:	2790      	movs	r7, #144	; 0x90
 80013ca:	007f      	lsls	r7, r7, #1
 80013cc:	4239      	tst	r1, r7
 80013ce:	d05b      	beq.n	8001488 <HAL_UART_IRQHandler+0xf0>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 80013d0:	2601      	movs	r6, #1
 80013d2:	422a      	tst	r2, r5
 80013d4:	d005      	beq.n	80013e2 <HAL_UART_IRQHandler+0x4a>
 80013d6:	05cd      	lsls	r5, r1, #23
 80013d8:	d503      	bpl.n	80013e2 <HAL_UART_IRQHandler+0x4a>
    {
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
 80013da:	621e      	str	r6, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80013dc:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 80013de:	4335      	orrs	r5, r6
 80013e0:	66e5      	str	r5, [r4, #108]	; 0x6c
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80013e2:	2502      	movs	r5, #2
 80013e4:	422a      	tst	r2, r5
 80013e6:	d006      	beq.n	80013f6 <HAL_UART_IRQHandler+0x5e>
 80013e8:	2800      	cmp	r0, #0
 80013ea:	d004      	beq.n	80013f6 <HAL_UART_IRQHandler+0x5e>
    {
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80013ec:	2604      	movs	r6, #4
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
    {
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
 80013ee:	621d      	str	r5, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80013f0:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 80013f2:	4335      	orrs	r5, r6
 80013f4:	66e5      	str	r5, [r4, #108]	; 0x6c
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80013f6:	2504      	movs	r5, #4
 80013f8:	422a      	tst	r2, r5
 80013fa:	d006      	beq.n	800140a <HAL_UART_IRQHandler+0x72>
 80013fc:	2800      	cmp	r0, #0
 80013fe:	d004      	beq.n	800140a <HAL_UART_IRQHandler+0x72>
    {
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001400:	2602      	movs	r6, #2
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
    {
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
 8001402:	621d      	str	r5, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001404:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8001406:	4335      	orrs	r5, r6
 8001408:	66e5      	str	r5, [r4, #108]	; 0x6c
    }
    
    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if(((isrflags & USART_ISR_ORE) != RESET) &&
 800140a:	0715      	lsls	r5, r2, #28
 800140c:	d508      	bpl.n	8001420 <HAL_UART_IRQHandler+0x88>
 800140e:	068d      	lsls	r5, r1, #26
 8001410:	d401      	bmi.n	8001416 <HAL_UART_IRQHandler+0x7e>
       (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 8001412:	2800      	cmp	r0, #0
 8001414:	d004      	beq.n	8001420 <HAL_UART_IRQHandler+0x88>
    {
      __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
 8001416:	2008      	movs	r0, #8
 8001418:	6218      	str	r0, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800141a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800141c:	4303      	orrs	r3, r0
 800141e:	66e3      	str	r3, [r4, #108]	; 0x6c
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001420:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8001422:	2b00      	cmp	r3, #0
 8001424:	d100      	bne.n	8001428 <HAL_UART_IRQHandler+0x90>
 8001426:	e07e      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
    {
      /* UART in mode Receiver ---------------------------------------------------*/
      if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001428:	2320      	movs	r3, #32
 800142a:	421a      	tst	r2, r3
 800142c:	d004      	beq.n	8001438 <HAL_UART_IRQHandler+0xa0>
 800142e:	4219      	tst	r1, r3
 8001430:	d002      	beq.n	8001438 <HAL_UART_IRQHandler+0xa0>
      {
        UART_Receive_IT(huart);
 8001432:	0020      	movs	r0, r4
 8001434:	f7ff ff72 	bl	800131c <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
 8001438:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
          (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
      {  
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800143a:	0020      	movs	r0, r4
        UART_Receive_IT(huart);
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
 800143c:	071b      	lsls	r3, r3, #28
 800143e:	d404      	bmi.n	800144a <HAL_UART_IRQHandler+0xb2>
          (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
 8001440:	6823      	ldr	r3, [r4, #0]
 8001442:	689d      	ldr	r5, [r3, #8]
        UART_Receive_IT(huart);
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
 8001444:	2340      	movs	r3, #64	; 0x40
 8001446:	401d      	ands	r5, r3
 8001448:	d01a      	beq.n	8001480 <HAL_UART_IRQHandler+0xe8>
          (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
      {  
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800144a:	f7ff ff55 	bl	80012f8 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800144e:	2140      	movs	r1, #64	; 0x40
 8001450:	6823      	ldr	r3, [r4, #0]
 8001452:	689a      	ldr	r2, [r3, #8]
 8001454:	420a      	tst	r2, r1
 8001456:	d00f      	beq.n	8001478 <HAL_UART_IRQHandler+0xe0>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001458:	689a      	ldr	r2, [r3, #8]

          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 800145a:	6e60      	ldr	r0, [r4, #100]	; 0x64
        UART_EndRxTransfer(huart);

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800145c:	438a      	bics	r2, r1
 800145e:	609a      	str	r2, [r3, #8]

          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8001460:	2800      	cmp	r0, #0
 8001462:	d009      	beq.n	8001478 <HAL_UART_IRQHandler+0xe0>
          {
            /* Set the UART DMA Abort callback : 
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8001464:	4b30      	ldr	r3, [pc, #192]	; (8001528 <HAL_UART_IRQHandler+0x190>)
 8001466:	6383      	str	r3, [r0, #56]	; 0x38

            /* Abort DMA RX */
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8001468:	f7ff f894 	bl	8000594 <HAL_DMA_Abort_IT>
 800146c:	2800      	cmp	r0, #0
 800146e:	d05a      	beq.n	8001526 <HAL_UART_IRQHandler+0x18e>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001470:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8001472:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001474:	4798      	blx	r3
 8001476:	e056      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
            }
          }
          else
          {
            /* Call user error callback */
            HAL_UART_ErrorCallback(huart);
 8001478:	0020      	movs	r0, r4
 800147a:	f7ff ff8b 	bl	8001394 <HAL_UART_ErrorCallback>
 800147e:	e052      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
      }
      else
      {
        /* Non Blocking error : transfer could go on. 
           Error is notified to user through user error callback */
        HAL_UART_ErrorCallback(huart);
 8001480:	f7ff ff88 	bl	8001394 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001484:	66e5      	str	r5, [r4, #108]	; 0x6c
 8001486:	e04e      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
    return;

  } /* End if some error occurs */

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if(((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
 8001488:	2080      	movs	r0, #128	; 0x80
 800148a:	0340      	lsls	r0, r0, #13
 800148c:	4202      	tst	r2, r0
 800148e:	d00b      	beq.n	80014a8 <HAL_UART_IRQHandler+0x110>
 8001490:	0275      	lsls	r5, r6, #9
 8001492:	d509      	bpl.n	80014a8 <HAL_UART_IRQHandler+0x110>
  {
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
    /* Set the UART state ready to be able to start again the process */
    huart->gState  = HAL_UART_STATE_READY;
 8001494:	0022      	movs	r2, r4
  } /* End if some error occurs */

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if(((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
  {
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
 8001496:	6218      	str	r0, [r3, #32]
    /* Set the UART state ready to be able to start again the process */
    huart->gState  = HAL_UART_STATE_READY;
 8001498:	2320      	movs	r3, #32
 800149a:	3269      	adds	r2, #105	; 0x69
 800149c:	7013      	strb	r3, [r2, #0]
    huart->RxState = HAL_UART_STATE_READY;
    HAL_UARTEx_WakeupCallback(huart);
 800149e:	0020      	movs	r0, r4
  if(((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
  {
    __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
    /* Set the UART state ready to be able to start again the process */
    huart->gState  = HAL_UART_STATE_READY;
    huart->RxState = HAL_UART_STATE_READY;
 80014a0:	7053      	strb	r3, [r2, #1]
    HAL_UARTEx_WakeupCallback(huart);
 80014a2:	f000 fa83 	bl	80019ac <HAL_UARTEx_WakeupCallback>
    return;
 80014a6:	e03e      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 80014a8:	2580      	movs	r5, #128	; 0x80
 80014aa:	422a      	tst	r2, r5
 80014ac:	d02c      	beq.n	8001508 <HAL_UART_IRQHandler+0x170>
 80014ae:	4229      	tst	r1, r5
 80014b0:	d02a      	beq.n	8001508 <HAL_UART_IRQHandler+0x170>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 80014b2:	0022      	movs	r2, r4
 80014b4:	3269      	adds	r2, #105	; 0x69
 80014b6:	7812      	ldrb	r2, [r2, #0]
 80014b8:	2a21      	cmp	r2, #33	; 0x21
 80014ba:	d134      	bne.n	8001526 <HAL_UART_IRQHandler+0x18e>
  {
    if(huart->TxXferCount == 0U)
 80014bc:	0020      	movs	r0, r4
 80014be:	3052      	adds	r0, #82	; 0x52
 80014c0:	8802      	ldrh	r2, [r0, #0]
 80014c2:	2a00      	cmp	r2, #0
 80014c4:	d107      	bne.n	80014d6 <HAL_UART_IRQHandler+0x13e>
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);

      /* Enable the UART Transmit Complete Interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80014c6:	2140      	movs	r1, #64	; 0x40
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
  {
    if(huart->TxXferCount == 0U)
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 80014c8:	681a      	ldr	r2, [r3, #0]
 80014ca:	43aa      	bics	r2, r5
 80014cc:	601a      	str	r2, [r3, #0]

      /* Enable the UART Transmit Complete Interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80014ce:	681a      	ldr	r2, [r3, #0]
 80014d0:	430a      	orrs	r2, r1
 80014d2:	601a      	str	r2, [r3, #0]
 80014d4:	e027      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>

      return HAL_OK;
    }
    else
    {
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80014d6:	2180      	movs	r1, #128	; 0x80
 80014d8:	68a5      	ldr	r5, [r4, #8]
 80014da:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80014dc:	0149      	lsls	r1, r1, #5
 80014de:	428d      	cmp	r5, r1
 80014e0:	d109      	bne.n	80014f6 <HAL_UART_IRQHandler+0x15e>
 80014e2:	6921      	ldr	r1, [r4, #16]
 80014e4:	2900      	cmp	r1, #0
 80014e6:	d106      	bne.n	80014f6 <HAL_UART_IRQHandler+0x15e>
      {
        tmp = (uint16_t*) huart->pTxBuffPtr;
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 80014e8:	8811      	ldrh	r1, [r2, #0]
        huart->pTxBuffPtr += 2U;
 80014ea:	3202      	adds	r2, #2
    else
    {
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
      {
        tmp = (uint16_t*) huart->pTxBuffPtr;
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 80014ec:	05c9      	lsls	r1, r1, #23
 80014ee:	0dc9      	lsrs	r1, r1, #23
 80014f0:	6299      	str	r1, [r3, #40]	; 0x28
        huart->pTxBuffPtr += 2U;
 80014f2:	64e2      	str	r2, [r4, #76]	; 0x4c
 80014f4:	e003      	b.n	80014fe <HAL_UART_IRQHandler+0x166>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
 80014f6:	1c51      	adds	r1, r2, #1
 80014f8:	64e1      	str	r1, [r4, #76]	; 0x4c
 80014fa:	7812      	ldrb	r2, [r2, #0]
 80014fc:	629a      	str	r2, [r3, #40]	; 0x28
      }
      huart->TxXferCount--;
 80014fe:	8803      	ldrh	r3, [r0, #0]
 8001500:	3b01      	subs	r3, #1
 8001502:	b29b      	uxth	r3, r3
 8001504:	8003      	strh	r3, [r0, #0]
 8001506:	e00e      	b.n	8001526 <HAL_UART_IRQHandler+0x18e>
    UART_Transmit_IT(huart);
    return;
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8001508:	2040      	movs	r0, #64	; 0x40
 800150a:	4202      	tst	r2, r0
 800150c:	d00b      	beq.n	8001526 <HAL_UART_IRQHandler+0x18e>
 800150e:	4201      	tst	r1, r0
 8001510:	d009      	beq.n	8001526 <HAL_UART_IRQHandler+0x18e>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001512:	681a      	ldr	r2, [r3, #0]
 8001514:	4382      	bics	r2, r0
 8001516:	601a      	str	r2, [r3, #0]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8001518:	0023      	movs	r3, r4
 800151a:	2220      	movs	r2, #32
 800151c:	3369      	adds	r3, #105	; 0x69
 800151e:	701a      	strb	r2, [r3, #0]

  HAL_UART_TxCpltCallback(huart);
 8001520:	0020      	movs	r0, r4
 8001522:	f7ff fef9 	bl	8001318 <HAL_UART_TxCpltCallback>
  {
    UART_EndTransmit_IT(huart);
    return;
  }

}
 8001526:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001528:	0800152d 	.word	0x0800152d

0800152c <UART_DMAAbortOnError>:
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
 800152c:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0;
 800152e:	2300      	movs	r3, #0
 8001530:	0002      	movs	r2, r0
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8001532:	b510      	push	{r4, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
  huart->RxXferCount = 0;
 8001534:	325a      	adds	r2, #90	; 0x5a
 8001536:	8013      	strh	r3, [r2, #0]
  huart->TxXferCount = 0;
 8001538:	3a08      	subs	r2, #8
 800153a:	8013      	strh	r3, [r2, #0]

  HAL_UART_ErrorCallback(huart);
 800153c:	f7ff ff2a 	bl	8001394 <HAL_UART_ErrorCallback>
}
 8001540:	bd10      	pop	{r4, pc}
	...

08001544 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8001544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001546:	0005      	movs	r5, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001548:	6803      	ldr	r3, [r0, #0]
 800154a:	6929      	ldr	r1, [r5, #16]
 800154c:	6880      	ldr	r0, [r0, #8]
 800154e:	681a      	ldr	r2, [r3, #0]
 8001550:	4308      	orrs	r0, r1
 8001552:	6969      	ldr	r1, [r5, #20]
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8001554:	4e82      	ldr	r6, [pc, #520]	; (8001760 <UART_SetConfig+0x21c>)
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001556:	4308      	orrs	r0, r1
 8001558:	69e9      	ldr	r1, [r5, #28]
 800155a:	4308      	orrs	r0, r1
 800155c:	4981      	ldr	r1, [pc, #516]	; (8001764 <UART_SetConfig+0x220>)
 800155e:	400a      	ands	r2, r1
 8001560:	4302      	orrs	r2, r0
 8001562:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001564:	6859      	ldr	r1, [r3, #4]
 8001566:	4a80      	ldr	r2, [pc, #512]	; (8001768 <UART_SetConfig+0x224>)
 8001568:	400a      	ands	r2, r1
 800156a:	68e9      	ldr	r1, [r5, #12]
 800156c:	430a      	orrs	r2, r1
 800156e:	605a      	str	r2, [r3, #4]
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8001570:	69aa      	ldr	r2, [r5, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8001572:	42b3      	cmp	r3, r6
 8001574:	d001      	beq.n	800157a <UART_SetConfig+0x36>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8001576:	6a29      	ldr	r1, [r5, #32]
 8001578:	430a      	orrs	r2, r1
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800157a:	6898      	ldr	r0, [r3, #8]
 800157c:	497b      	ldr	r1, [pc, #492]	; (800176c <UART_SetConfig+0x228>)
 800157e:	4001      	ands	r1, r0
 8001580:	430a      	orrs	r2, r1
 8001582:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001584:	4a7a      	ldr	r2, [pc, #488]	; (8001770 <UART_SetConfig+0x22c>)
 8001586:	4293      	cmp	r3, r2
 8001588:	d105      	bne.n	8001596 <UART_SetConfig+0x52>
 800158a:	4b7a      	ldr	r3, [pc, #488]	; (8001774 <UART_SetConfig+0x230>)
 800158c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800158e:	2303      	movs	r3, #3
 8001590:	4013      	ands	r3, r2
 8001592:	4a79      	ldr	r2, [pc, #484]	; (8001778 <UART_SetConfig+0x234>)
 8001594:	e007      	b.n	80015a6 <UART_SetConfig+0x62>
 8001596:	4a79      	ldr	r2, [pc, #484]	; (800177c <UART_SetConfig+0x238>)
 8001598:	4293      	cmp	r3, r2
 800159a:	d106      	bne.n	80015aa <UART_SetConfig+0x66>
 800159c:	4b75      	ldr	r3, [pc, #468]	; (8001774 <UART_SetConfig+0x230>)
 800159e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80015a0:	230c      	movs	r3, #12
 80015a2:	4013      	ands	r3, r2
 80015a4:	4a76      	ldr	r2, [pc, #472]	; (8001780 <UART_SetConfig+0x23c>)
 80015a6:	5cd4      	ldrb	r4, [r2, r3]
 80015a8:	e021      	b.n	80015ee <UART_SetConfig+0xaa>
 80015aa:	4a76      	ldr	r2, [pc, #472]	; (8001784 <UART_SetConfig+0x240>)
 80015ac:	2400      	movs	r4, #0
 80015ae:	4293      	cmp	r3, r2
 80015b0:	d01d      	beq.n	80015ee <UART_SetConfig+0xaa>
 80015b2:	4a75      	ldr	r2, [pc, #468]	; (8001788 <UART_SetConfig+0x244>)
 80015b4:	4293      	cmp	r3, r2
 80015b6:	d01a      	beq.n	80015ee <UART_SetConfig+0xaa>
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg                     = 0x00000000U;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 80015b8:	3410      	adds	r4, #16
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80015ba:	42b3      	cmp	r3, r6
 80015bc:	d117      	bne.n	80015ee <UART_SetConfig+0xaa>
 80015be:	22c0      	movs	r2, #192	; 0xc0
 80015c0:	2180      	movs	r1, #128	; 0x80
 80015c2:	4b6c      	ldr	r3, [pc, #432]	; (8001774 <UART_SetConfig+0x230>)
 80015c4:	0112      	lsls	r2, r2, #4
 80015c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80015c8:	00c9      	lsls	r1, r1, #3
 80015ca:	4013      	ands	r3, r2
 80015cc:	3c0c      	subs	r4, #12
 80015ce:	428b      	cmp	r3, r1
 80015d0:	d00d      	beq.n	80015ee <UART_SetConfig+0xaa>
 80015d2:	d803      	bhi.n	80015dc <UART_SetConfig+0x98>
 80015d4:	2400      	movs	r4, #0
 80015d6:	42a3      	cmp	r3, r4
 80015d8:	d009      	beq.n	80015ee <UART_SetConfig+0xaa>
 80015da:	e007      	b.n	80015ec <UART_SetConfig+0xa8>
 80015dc:	2180      	movs	r1, #128	; 0x80
 80015de:	2402      	movs	r4, #2
 80015e0:	0109      	lsls	r1, r1, #4
 80015e2:	428b      	cmp	r3, r1
 80015e4:	d003      	beq.n	80015ee <UART_SetConfig+0xaa>
 80015e6:	3406      	adds	r4, #6
 80015e8:	4293      	cmp	r3, r2
 80015ea:	d000      	beq.n	80015ee <UART_SetConfig+0xaa>
 80015ec:	2410      	movs	r4, #16
  uint32_t frequency = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_USART2);
 80015ee:	2002      	movs	r0, #2
 80015f0:	f7ff fd8a 	bl	8001108 <HAL_RCCEx_GetPeriphCLKFreq>

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
 80015f4:	682f      	ldr	r7, [r5, #0]
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
  uint32_t frequency = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_USART2);
 80015f6:	0003      	movs	r3, r0

  /* Check LPUART instance */
  if(UART_INSTANCE_LOWPOWER(huart))
 80015f8:	42b7      	cmp	r7, r6
 80015fa:	d138      	bne.n	800166e <UART_SetConfig+0x12a>
  {
    /* Retrieve frequency clock */
    tmpreg = 0;

    switch (clocksource)
 80015fc:	2c08      	cmp	r4, #8
 80015fe:	d900      	bls.n	8001602 <UART_SetConfig+0xbe>
 8001600:	e0a4      	b.n	800174c <UART_SetConfig+0x208>
 8001602:	0020      	movs	r0, r4
 8001604:	f7fe fd80 	bl	8000108 <__gnu_thumb1_case_uqi>
 8001608:	a208a205 	.word	0xa208a205
 800160c:	a2a2a20f 	.word	0xa2a2a20f
 8001610:	a4          	.byte	0xa4
 8001611:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
 8001612:	f7ff fc7d 	bl	8000f10 <HAL_RCC_GetPCLK1Freq>
 8001616:	e008      	b.n	800162a <UART_SetConfig+0xe6>
      break;
    case UART_CLOCKSOURCE_HSI:
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8001618:	4b56      	ldr	r3, [pc, #344]	; (8001774 <UART_SetConfig+0x230>)
 800161a:	681b      	ldr	r3, [r3, #0]
 800161c:	06db      	lsls	r3, r3, #27
 800161e:	d500      	bpl.n	8001622 <UART_SetConfig+0xde>
 8001620:	e099      	b.n	8001756 <UART_SetConfig+0x212>
      {
        tmpreg = (uint32_t) (HSI_VALUE >> 2U);
      }
      else
      {
        tmpreg = (uint32_t) HSI_VALUE;
 8001622:	4b5a      	ldr	r3, [pc, #360]	; (800178c <UART_SetConfig+0x248>)
 8001624:	e006      	b.n	8001634 <UART_SetConfig+0xf0>
      }
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
 8001626:	f7ff fb7d 	bl	8000d24 <HAL_RCC_GetSysClockFreq>
 800162a:	2400      	movs	r4, #0
 800162c:	1e03      	subs	r3, r0, #0
        ret = HAL_ERROR;
      break;
    }

    /* if proper clock source reported */
    if (tmpreg != 0)
 800162e:	42a3      	cmp	r3, r4
 8001630:	d100      	bne.n	8001634 <UART_SetConfig+0xf0>
 8001632:	e092      	b.n	800175a <UART_SetConfig+0x216>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ( (tmpreg < (3 * huart->Init.BaudRate) ) ||
 8001634:	2103      	movs	r1, #3
 8001636:	686a      	ldr	r2, [r5, #4]
           (tmpreg > (4096 * huart->Init.BaudRate) ))
      {
        ret = HAL_ERROR;
 8001638:	2401      	movs	r4, #1

    /* if proper clock source reported */
    if (tmpreg != 0)
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ( (tmpreg < (3 * huart->Init.BaudRate) ) ||
 800163a:	4351      	muls	r1, r2
 800163c:	4299      	cmp	r1, r3
 800163e:	d900      	bls.n	8001642 <UART_SetConfig+0xfe>
 8001640:	e08b      	b.n	800175a <UART_SetConfig+0x216>
 8001642:	0311      	lsls	r1, r2, #12
 8001644:	4299      	cmp	r1, r3
 8001646:	d200      	bcs.n	800164a <UART_SetConfig+0x106>
 8001648:	e087      	b.n	800175a <UART_SetConfig+0x216>
      {
        ret = HAL_ERROR;
      }
      else
      {
        tmpreg = (uint32_t)(UART_DIV_LPUART(tmpreg, huart->Init.BaudRate));
 800164a:	2700      	movs	r7, #0
 800164c:	0856      	lsrs	r6, r2, #1
 800164e:	0e19      	lsrs	r1, r3, #24
 8001650:	0218      	lsls	r0, r3, #8
 8001652:	1980      	adds	r0, r0, r6
 8001654:	4179      	adcs	r1, r7
 8001656:	003b      	movs	r3, r7
 8001658:	f7fe fdec 	bl	8000234 <__aeabi_uldivmod>
   
        if ((tmpreg >= UART_LPUART_BRR_MIN) && (tmpreg <= UART_LPUART_BRR_MAX))
 800165c:	4b4c      	ldr	r3, [pc, #304]	; (8001790 <UART_SetConfig+0x24c>)
 800165e:	18c2      	adds	r2, r0, r3
 8001660:	4b4c      	ldr	r3, [pc, #304]	; (8001794 <UART_SetConfig+0x250>)
 8001662:	429a      	cmp	r2, r3
 8001664:	d879      	bhi.n	800175a <UART_SetConfig+0x216>
        {
           huart->Instance->BRR = tmpreg;
 8001666:	682b      	ldr	r3, [r5, #0]
 8001668:	003c      	movs	r4, r7
 800166a:	60d8      	str	r0, [r3, #12]
 800166c:	e075      	b.n	800175a <UART_SetConfig+0x216>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800166e:	2280      	movs	r2, #128	; 0x80
 8001670:	69e9      	ldr	r1, [r5, #28]
 8001672:	0212      	lsls	r2, r2, #8
 8001674:	4291      	cmp	r1, r2
 8001676:	d139      	bne.n	80016ec <UART_SetConfig+0x1a8>
  {
    switch (clocksource)
 8001678:	2c08      	cmp	r4, #8
 800167a:	d82d      	bhi.n	80016d8 <UART_SetConfig+0x194>
 800167c:	0020      	movs	r0, r4
 800167e:	f7fe fd43 	bl	8000108 <__gnu_thumb1_case_uqi>
 8001682:	0705      	.short	0x0705
 8001684:	2b1a2b0a 	.word	0x2b1a2b0a
 8001688:	2b2b      	.short	0x2b2b
 800168a:	20          	.byte	0x20
 800168b:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(frequency, huart->Init.BaudRate));
 800168c:	0058      	lsls	r0, r3, #1
 800168e:	e015      	b.n	80016bc <UART_SetConfig+0x178>
      break;
    case UART_CLOCKSOURCE_PCLK2:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8001690:	f7ff fc4e 	bl	8000f30 <HAL_RCC_GetPCLK2Freq>
 8001694:	e011      	b.n	80016ba <UART_SetConfig+0x176>
      break;
    case UART_CLOCKSOURCE_HSI:
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8001696:	4b37      	ldr	r3, [pc, #220]	; (8001774 <UART_SetConfig+0x230>)
 8001698:	6869      	ldr	r1, [r5, #4]
 800169a:	681c      	ldr	r4, [r3, #0]
 800169c:	2310      	movs	r3, #16
      {
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((HSI_VALUE >> 2U), huart->Init.BaudRate));
 800169e:	0848      	lsrs	r0, r1, #1
      break;
    case UART_CLOCKSOURCE_PCLK2:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_HSI:
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80016a0:	401c      	ands	r4, r3
 80016a2:	d002      	beq.n	80016aa <UART_SetConfig+0x166>
      {
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((HSI_VALUE >> 2U), huart->Init.BaudRate));
 80016a4:	4b3c      	ldr	r3, [pc, #240]	; (8001798 <UART_SetConfig+0x254>)
 80016a6:	18c0      	adds	r0, r0, r3
 80016a8:	e011      	b.n	80016ce <UART_SetConfig+0x18a>
      }
      else
      {
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
 80016aa:	4b3c      	ldr	r3, [pc, #240]	; (800179c <UART_SetConfig+0x258>)
 80016ac:	18c0      	adds	r0, r0, r3
 80016ae:	f7fe fd35 	bl	800011c <__aeabi_uidiv>
 80016b2:	b280      	uxth	r0, r0
 80016b4:	e012      	b.n	80016dc <UART_SetConfig+0x198>
      }
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80016b6:	f7ff fb35 	bl	8000d24 <HAL_RCC_GetSysClockFreq>
 80016ba:	0040      	lsls	r0, r0, #1
 80016bc:	686b      	ldr	r3, [r5, #4]
 80016be:	085b      	lsrs	r3, r3, #1
 80016c0:	e003      	b.n	80016ca <UART_SetConfig+0x186>
      break;
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80016c2:	686b      	ldr	r3, [r5, #4]
 80016c4:	0858      	lsrs	r0, r3, #1
 80016c6:	2380      	movs	r3, #128	; 0x80
 80016c8:	025b      	lsls	r3, r3, #9
 80016ca:	6869      	ldr	r1, [r5, #4]
 80016cc:	18c0      	adds	r0, r0, r3
 80016ce:	f7fe fd25 	bl	800011c <__aeabi_uidiv>
{
  uint32_t tmpreg                     = 0x00000000U;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000U;
  uint16_t usartdiv                   = 0x0000U;
  HAL_StatusTypeDef ret               = HAL_OK;
 80016d2:	2400      	movs	r4, #0
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80016d4:	b280      	uxth	r0, r0
      break;
 80016d6:	e001      	b.n	80016dc <UART_SetConfig+0x198>
    case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 80016d8:	2401      	movs	r4, #1
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg                     = 0x00000000U;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000U;
  uint16_t usartdiv                   = 0x0000U;
 80016da:	2000      	movs	r0, #0
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0U;
    brrtemp |= (uint16_t)((uint16_t)(usartdiv & (uint16_t)0x000FU) >> (uint16_t)1U);
 80016dc:	220f      	movs	r2, #15
 80016de:	0703      	lsls	r3, r0, #28
 80016e0:	0f5b      	lsrs	r3, r3, #29
 80016e2:	4390      	bics	r0, r2
    huart->Instance->BRR = brrtemp;
 80016e4:	682a      	ldr	r2, [r5, #0]
 80016e6:	4318      	orrs	r0, r3
 80016e8:	60d0      	str	r0, [r2, #12]
 80016ea:	e036      	b.n	800175a <UART_SetConfig+0x216>
  }
  else
  {
    switch (clocksource)
 80016ec:	2c08      	cmp	r4, #8
 80016ee:	d82d      	bhi.n	800174c <UART_SetConfig+0x208>
 80016f0:	0020      	movs	r0, r4
 80016f2:	f7fe fd09 	bl	8000108 <__gnu_thumb1_case_uqi>
 80016f6:	0805      	.short	0x0805
 80016f8:	2b232b13 	.word	0x2b232b13
 80016fc:	2b2b      	.short	0x2b2b
 80016fe:	26          	.byte	0x26
 80016ff:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8001700:	f7ff fc06 	bl	8000f10 <HAL_RCC_GetPCLK1Freq>
 8001704:	e001      	b.n	800170a <UART_SetConfig+0x1c6>
      break;
    case UART_CLOCKSOURCE_PCLK2:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8001706:	f7ff fc13 	bl	8000f30 <HAL_RCC_GetPCLK2Freq>
 800170a:	6869      	ldr	r1, [r5, #4]
 800170c:	084b      	lsrs	r3, r1, #1
 800170e:	1818      	adds	r0, r3, r0
 8001710:	f7fe fd04 	bl	800011c <__aeabi_uidiv>
 8001714:	b280      	uxth	r0, r0
 8001716:	60f8      	str	r0, [r7, #12]
{
  uint32_t tmpreg                     = 0x00000000U;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000U;
  uint16_t usartdiv                   = 0x0000U;
  HAL_StatusTypeDef ret               = HAL_OK;
 8001718:	2400      	movs	r4, #0
    case UART_CLOCKSOURCE_PCLK1:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_PCLK2:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
      break;
 800171a:	e01e      	b.n	800175a <UART_SetConfig+0x216>
    case UART_CLOCKSOURCE_HSI:
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800171c:	4b15      	ldr	r3, [pc, #84]	; (8001774 <UART_SetConfig+0x230>)
 800171e:	6869      	ldr	r1, [r5, #4]
 8001720:	681c      	ldr	r4, [r3, #0]
 8001722:	2310      	movs	r3, #16
      {
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16((HSI_VALUE >> 2U), huart->Init.BaudRate));
 8001724:	0848      	lsrs	r0, r1, #1
      break;
    case UART_CLOCKSOURCE_PCLK2:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_HSI:
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8001726:	401c      	ands	r4, r3
 8001728:	d001      	beq.n	800172e <UART_SetConfig+0x1ea>
      {
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16((HSI_VALUE >> 2U), huart->Init.BaudRate));
 800172a:	4b1d      	ldr	r3, [pc, #116]	; (80017a0 <UART_SetConfig+0x25c>)
 800172c:	e7ef      	b.n	800170e <UART_SetConfig+0x1ca>
      }
      else
      {
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 800172e:	4b17      	ldr	r3, [pc, #92]	; (800178c <UART_SetConfig+0x248>)
 8001730:	18c0      	adds	r0, r0, r3
 8001732:	f7fe fcf3 	bl	800011c <__aeabi_uidiv>
 8001736:	b280      	uxth	r0, r0
 8001738:	60f8      	str	r0, [r7, #12]
 800173a:	e00e      	b.n	800175a <UART_SetConfig+0x216>
      }
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800173c:	f7ff faf2 	bl	8000d24 <HAL_RCC_GetSysClockFreq>
 8001740:	e7e3      	b.n	800170a <UART_SetConfig+0x1c6>
      break;
    case UART_CLOCKSOURCE_LSE:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8001742:	2380      	movs	r3, #128	; 0x80
 8001744:	6869      	ldr	r1, [r5, #4]
 8001746:	021b      	lsls	r3, r3, #8
 8001748:	0848      	lsrs	r0, r1, #1
 800174a:	e7e0      	b.n	800170e <UART_SetConfig+0x1ca>
      break;
    case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 800174c:	2401      	movs	r4, #1
      break;
    }
  }

  return ret;
 800174e:	e004      	b.n	800175a <UART_SetConfig+0x216>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
      break;
    case UART_CLOCKSOURCE_LSE:
      tmpreg = (uint32_t) LSE_VALUE;
 8001750:	2380      	movs	r3, #128	; 0x80
 8001752:	021b      	lsls	r3, r3, #8
 8001754:	e76e      	b.n	8001634 <UART_SetConfig+0xf0>
      tmpreg = HAL_RCC_GetPCLK1Freq();
      break;
    case UART_CLOCKSOURCE_HSI:
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
      {
        tmpreg = (uint32_t) (HSI_VALUE >> 2U);
 8001756:	4b12      	ldr	r3, [pc, #72]	; (80017a0 <UART_SetConfig+0x25c>)
 8001758:	e76c      	b.n	8001634 <UART_SetConfig+0xf0>
    }
  }

  return ret;

}
 800175a:	0020      	movs	r0, r4
 800175c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800175e:	46c0      	nop			; (mov r8, r8)
 8001760:	40004800 	.word	0x40004800
 8001764:	efff69f3 	.word	0xefff69f3
 8001768:	ffffcfff 	.word	0xffffcfff
 800176c:	fffff4ff 	.word	0xfffff4ff
 8001770:	40013800 	.word	0x40013800
 8001774:	40021000 	.word	0x40021000
 8001778:	08001ce0 	.word	0x08001ce0
 800177c:	40004400 	.word	0x40004400
 8001780:	08001ce4 	.word	0x08001ce4
 8001784:	40004c00 	.word	0x40004c00
 8001788:	40005000 	.word	0x40005000
 800178c:	00f42400 	.word	0x00f42400
 8001790:	fffffd00 	.word	0xfffffd00
 8001794:	000ffcff 	.word	0x000ffcff
 8001798:	007a1200 	.word	0x007a1200
 800179c:	01e84800 	.word	0x01e84800
 80017a0:	003d0900 	.word	0x003d0900

080017a4 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80017a4:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @brief Configure the UART peripheral advanced features.
  * @param huart: UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80017a6:	b530      	push	{r4, r5, lr}
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80017a8:	07da      	lsls	r2, r3, #31
 80017aa:	d506      	bpl.n	80017ba <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80017ac:	6801      	ldr	r1, [r0, #0]
 80017ae:	4a28      	ldr	r2, [pc, #160]	; (8001850 <UART_AdvFeatureConfig+0xac>)
 80017b0:	684c      	ldr	r4, [r1, #4]
 80017b2:	4022      	ands	r2, r4
 80017b4:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80017b6:	4322      	orrs	r2, r4
 80017b8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80017ba:	079a      	lsls	r2, r3, #30
 80017bc:	d506      	bpl.n	80017cc <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80017be:	6801      	ldr	r1, [r0, #0]
 80017c0:	4a24      	ldr	r2, [pc, #144]	; (8001854 <UART_AdvFeatureConfig+0xb0>)
 80017c2:	684c      	ldr	r4, [r1, #4]
 80017c4:	4022      	ands	r2, r4
 80017c6:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80017c8:	4322      	orrs	r2, r4
 80017ca:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80017cc:	075a      	lsls	r2, r3, #29
 80017ce:	d506      	bpl.n	80017de <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80017d0:	6801      	ldr	r1, [r0, #0]
 80017d2:	4a21      	ldr	r2, [pc, #132]	; (8001858 <UART_AdvFeatureConfig+0xb4>)
 80017d4:	684c      	ldr	r4, [r1, #4]
 80017d6:	4022      	ands	r2, r4
 80017d8:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80017da:	4322      	orrs	r2, r4
 80017dc:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80017de:	071a      	lsls	r2, r3, #28
 80017e0:	d506      	bpl.n	80017f0 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80017e2:	6801      	ldr	r1, [r0, #0]
 80017e4:	4a1d      	ldr	r2, [pc, #116]	; (800185c <UART_AdvFeatureConfig+0xb8>)
 80017e6:	684c      	ldr	r4, [r1, #4]
 80017e8:	4022      	ands	r2, r4
 80017ea:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80017ec:	4322      	orrs	r2, r4
 80017ee:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80017f0:	06da      	lsls	r2, r3, #27
 80017f2:	d506      	bpl.n	8001802 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80017f4:	6801      	ldr	r1, [r0, #0]
 80017f6:	4a1a      	ldr	r2, [pc, #104]	; (8001860 <UART_AdvFeatureConfig+0xbc>)
 80017f8:	688c      	ldr	r4, [r1, #8]
 80017fa:	4022      	ands	r2, r4
 80017fc:	6b84      	ldr	r4, [r0, #56]	; 0x38
 80017fe:	4322      	orrs	r2, r4
 8001800:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8001802:	069a      	lsls	r2, r3, #26
 8001804:	d506      	bpl.n	8001814 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8001806:	6801      	ldr	r1, [r0, #0]
 8001808:	4a16      	ldr	r2, [pc, #88]	; (8001864 <UART_AdvFeatureConfig+0xc0>)
 800180a:	688c      	ldr	r4, [r1, #8]
 800180c:	4022      	ands	r2, r4
 800180e:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8001810:	4322      	orrs	r2, r4
 8001812:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8001814:	065a      	lsls	r2, r3, #25
 8001816:	d510      	bpl.n	800183a <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8001818:	6801      	ldr	r1, [r0, #0]
 800181a:	4a13      	ldr	r2, [pc, #76]	; (8001868 <UART_AdvFeatureConfig+0xc4>)
 800181c:	684d      	ldr	r5, [r1, #4]
 800181e:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8001820:	402a      	ands	r2, r5
 8001822:	4322      	orrs	r2, r4
 8001824:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8001826:	2280      	movs	r2, #128	; 0x80
 8001828:	0352      	lsls	r2, r2, #13
 800182a:	4294      	cmp	r4, r2
 800182c:	d105      	bne.n	800183a <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800182e:	684c      	ldr	r4, [r1, #4]
 8001830:	4a0e      	ldr	r2, [pc, #56]	; (800186c <UART_AdvFeatureConfig+0xc8>)
 8001832:	4022      	ands	r2, r4
 8001834:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8001836:	4322      	orrs	r2, r4
 8001838:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800183a:	061b      	lsls	r3, r3, #24
 800183c:	d506      	bpl.n	800184c <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800183e:	6801      	ldr	r1, [r0, #0]
 8001840:	4b0b      	ldr	r3, [pc, #44]	; (8001870 <UART_AdvFeatureConfig+0xcc>)
 8001842:	684a      	ldr	r2, [r1, #4]
 8001844:	4013      	ands	r3, r2
 8001846:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8001848:	4313      	orrs	r3, r2
 800184a:	604b      	str	r3, [r1, #4]
  }
}
 800184c:	bd30      	pop	{r4, r5, pc}
 800184e:	46c0      	nop			; (mov r8, r8)
 8001850:	fffdffff 	.word	0xfffdffff
 8001854:	fffeffff 	.word	0xfffeffff
 8001858:	fffbffff 	.word	0xfffbffff
 800185c:	ffff7fff 	.word	0xffff7fff
 8001860:	ffffefff 	.word	0xffffefff
 8001864:	ffffdfff 	.word	0xffffdfff
 8001868:	ffefffff 	.word	0xffefffff
 800186c:	ff9fffff 	.word	0xff9fffff
 8001870:	fff7ffff 	.word	0xfff7ffff

08001874 <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8001874:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001876:	0004      	movs	r4, r0
 8001878:	000e      	movs	r6, r1
 800187a:	0015      	movs	r5, r2
 800187c:	001f      	movs	r7, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800187e:	6822      	ldr	r2, [r4, #0]
 8001880:	69d3      	ldr	r3, [r2, #28]
 8001882:	4033      	ands	r3, r6
 8001884:	1b9b      	subs	r3, r3, r6
 8001886:	4259      	negs	r1, r3
 8001888:	414b      	adcs	r3, r1
 800188a:	42ab      	cmp	r3, r5
 800188c:	d11f      	bne.n	80018ce <UART_WaitOnFlagUntilTimeout+0x5a>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 800188e:	9b06      	ldr	r3, [sp, #24]
 8001890:	3301      	adds	r3, #1
 8001892:	d0f5      	beq.n	8001880 <UART_WaitOnFlagUntilTimeout+0xc>
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
 8001894:	9b06      	ldr	r3, [sp, #24]
 8001896:	2b00      	cmp	r3, #0
 8001898:	d112      	bne.n	80018c0 <UART_WaitOnFlagUntilTimeout+0x4c>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800189a:	6823      	ldr	r3, [r4, #0]
 800189c:	4a0d      	ldr	r2, [pc, #52]	; (80018d4 <UART_WaitOnFlagUntilTimeout+0x60>)
 800189e:	6819      	ldr	r1, [r3, #0]

        huart->gState  = HAL_UART_STATE_READY;
        huart->RxState = HAL_UART_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 80018a0:	2003      	movs	r0, #3
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80018a2:	400a      	ands	r2, r1
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80018a4:	2101      	movs	r1, #1
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80018a6:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80018a8:	689a      	ldr	r2, [r3, #8]
 80018aa:	438a      	bics	r2, r1
 80018ac:	609a      	str	r2, [r3, #8]

        huart->gState  = HAL_UART_STATE_READY;
 80018ae:	0022      	movs	r2, r4
 80018b0:	2320      	movs	r3, #32
 80018b2:	3269      	adds	r2, #105	; 0x69
 80018b4:	7013      	strb	r3, [r2, #0]
        huart->RxState = HAL_UART_STATE_READY;
 80018b6:	7053      	strb	r3, [r2, #1]

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 80018b8:	2300      	movs	r3, #0
 80018ba:	3468      	adds	r4, #104	; 0x68
 80018bc:	7023      	strb	r3, [r4, #0]
 80018be:	e007      	b.n	80018d0 <UART_WaitOnFlagUntilTimeout+0x5c>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
 80018c0:	f7fe fdee 	bl	80004a0 <HAL_GetTick>
 80018c4:	9b06      	ldr	r3, [sp, #24]
 80018c6:	1bc0      	subs	r0, r0, r7
 80018c8:	4283      	cmp	r3, r0
 80018ca:	d2d8      	bcs.n	800187e <UART_WaitOnFlagUntilTimeout+0xa>
 80018cc:	e7e5      	b.n	800189a <UART_WaitOnFlagUntilTimeout+0x26>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80018ce:	2000      	movs	r0, #0
}
 80018d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80018d2:	46c0      	nop			; (mov r8, r8)
 80018d4:	fffffe5f 	.word	0xfffffe5f

080018d8 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 80018d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart = 0;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80018da:	2600      	movs	r6, #0
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 80018dc:	0004      	movs	r4, r0
  uint32_t tickstart = 0;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80018de:	66c6      	str	r6, [r0, #108]	; 0x6c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 80018e0:	f7fe fdde 	bl	80004a0 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80018e4:	6823      	ldr	r3, [r4, #0]

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 80018e6:	0005      	movs	r5, r0

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80018e8:	681b      	ldr	r3, [r3, #0]
 80018ea:	071b      	lsls	r3, r3, #28
 80018ec:	d404      	bmi.n	80018f8 <UART_CheckIdleState+0x20>
      /* Timeout occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80018ee:	6823      	ldr	r3, [r4, #0]
 80018f0:	681b      	ldr	r3, [r3, #0]
 80018f2:	075b      	lsls	r3, r3, #29
 80018f4:	d518      	bpl.n	8001928 <UART_CheckIdleState+0x50>
 80018f6:	e00c      	b.n	8001912 <UART_CheckIdleState+0x3a>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80018f8:	2180      	movs	r1, #128	; 0x80
 80018fa:	4b10      	ldr	r3, [pc, #64]	; (800193c <UART_CheckIdleState+0x64>)
 80018fc:	0032      	movs	r2, r6
 80018fe:	9300      	str	r3, [sp, #0]
 8001900:	0389      	lsls	r1, r1, #14
 8001902:	0003      	movs	r3, r0
 8001904:	0020      	movs	r0, r4
 8001906:	f7ff ffb5 	bl	8001874 <UART_WaitOnFlagUntilTimeout>
 800190a:	2800      	cmp	r0, #0
 800190c:	d0ef      	beq.n	80018ee <UART_CheckIdleState+0x16>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800190e:	2003      	movs	r0, #3
 8001910:	e012      	b.n	8001938 <UART_CheckIdleState+0x60>
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8001912:	2180      	movs	r1, #128	; 0x80
 8001914:	4b09      	ldr	r3, [pc, #36]	; (800193c <UART_CheckIdleState+0x64>)
 8001916:	2200      	movs	r2, #0
 8001918:	9300      	str	r3, [sp, #0]
 800191a:	03c9      	lsls	r1, r1, #15
 800191c:	002b      	movs	r3, r5
 800191e:	0020      	movs	r0, r4
 8001920:	f7ff ffa8 	bl	8001874 <UART_WaitOnFlagUntilTimeout>
 8001924:	2800      	cmp	r0, #0
 8001926:	d1f2      	bne.n	800190e <UART_CheckIdleState+0x36>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 8001928:	0022      	movs	r2, r4
 800192a:	2320      	movs	r3, #32
  huart->RxState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800192c:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 800192e:	3269      	adds	r2, #105	; 0x69
  huart->RxState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8001930:	3468      	adds	r4, #104	; 0x68
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 8001932:	7013      	strb	r3, [r2, #0]
  huart->RxState = HAL_UART_STATE_READY;
 8001934:	7053      	strb	r3, [r2, #1]

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8001936:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 8001938:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 800193a:	46c0      	nop			; (mov r8, r8)
 800193c:	01ffffff 	.word	0x01ffffff

08001940 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8001940:	b570      	push	{r4, r5, r6, lr}
 8001942:	1e04      	subs	r4, r0, #0
  /* Check the UART handle allocation */
  if(huart == NULL)
 8001944:	d101      	bne.n	800194a <HAL_UART_Init+0xa>
  {
    return HAL_ERROR;
 8001946:	2001      	movs	r0, #1
 8001948:	e02c      	b.n	80019a4 <HAL_UART_Init+0x64>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if(huart->gState == HAL_UART_STATE_RESET)
 800194a:	0005      	movs	r5, r0
 800194c:	3569      	adds	r5, #105	; 0x69
 800194e:	782b      	ldrb	r3, [r5, #0]
 8001950:	b2db      	uxtb	r3, r3
 8001952:	2b00      	cmp	r3, #0
 8001954:	d104      	bne.n	8001960 <HAL_UART_Init+0x20>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8001956:	0002      	movs	r2, r0
 8001958:	3268      	adds	r2, #104	; 0x68
 800195a:	7013      	strb	r3, [r2, #0]

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800195c:	f000 f8fa 	bl	8001b54 <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8001960:	2324      	movs	r3, #36	; 0x24

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 8001962:	2101      	movs	r1, #1
 8001964:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8001966:	702b      	strb	r3, [r5, #0]

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 8001968:	6813      	ldr	r3, [r2, #0]
 800196a:	438b      	bics	r3, r1
 800196c:	6013      	str	r3, [r2, #0]

  /* Set the UART Communication parameters */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800196e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001970:	2b00      	cmp	r3, #0
 8001972:	d002      	beq.n	800197a <HAL_UART_Init+0x3a>
  {
    UART_AdvFeatureConfig(huart);
 8001974:	0020      	movs	r0, r4
 8001976:	f7ff ff15 	bl	80017a4 <UART_AdvFeatureConfig>
  }

  if (UART_SetConfig(huart) == HAL_ERROR)
 800197a:	0020      	movs	r0, r4
 800197c:	f7ff fde2 	bl	8001544 <UART_SetConfig>
 8001980:	2801      	cmp	r0, #1
 8001982:	d0e0      	beq.n	8001946 <HAL_UART_Init+0x6>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001984:	6823      	ldr	r3, [r4, #0]
 8001986:	4a08      	ldr	r2, [pc, #32]	; (80019a8 <HAL_UART_Init+0x68>)
 8001988:	6859      	ldr	r1, [r3, #4]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800198a:	0020      	movs	r0, r4
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800198c:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800198e:	212a      	movs	r1, #42	; 0x2a
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001990:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001992:	689a      	ldr	r2, [r3, #8]
 8001994:	438a      	bics	r2, r1
 8001996:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 8001998:	681a      	ldr	r2, [r3, #0]
 800199a:	3929      	subs	r1, #41	; 0x29
 800199c:	430a      	orrs	r2, r1
 800199e:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 80019a0:	f7ff ff9a 	bl	80018d8 <UART_CheckIdleState>
}
 80019a4:	bd70      	pop	{r4, r5, r6, pc}
 80019a6:	46c0      	nop			; (mov r8, r8)
 80019a8:	ffffb7ff 	.word	0xffffb7ff

080019ac <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 80019ac:	4770      	bx	lr
	...

080019b0 <SystemClock_Config>:
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80019b0:	4a23      	ldr	r2, [pc, #140]	; (8001a40 <SystemClock_Config+0x90>)
 80019b2:	4b24      	ldr	r3, [pc, #144]	; (8001a44 <SystemClock_Config+0x94>)
 80019b4:	6811      	ldr	r1, [r2, #0]
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 80019b6:	b530      	push	{r4, r5, lr}
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80019b8:	400b      	ands	r3, r1
 80019ba:	2180      	movs	r1, #128	; 0x80
 80019bc:	0109      	lsls	r1, r1, #4
 80019be:	430b      	orrs	r3, r1
 80019c0:	6013      	str	r3, [r2, #0]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 80019c2:	2310      	movs	r3, #16
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 80019c4:	b09d      	sub	sp, #116	; 0x74

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 80019c6:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 80019c8:	2300      	movs	r3, #0
 80019ca:	9319      	str	r3, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_6;
 80019cc:	2380      	movs	r3, #128	; 0x80
 80019ce:	031b      	lsls	r3, r3, #12
 80019d0:	931a      	str	r3, [sp, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_3;
 80019d2:	2380      	movs	r3, #128	; 0x80
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80019d4:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80019d6:	2501      	movs	r5, #1
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_6;
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_3;
 80019d8:	041b      	lsls	r3, r3, #16
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80019da:	a80e      	add	r0, sp, #56	; 0x38
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80019dc:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80019de:	9511      	str	r5, [sp, #68]	; 0x44
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80019e0:	9418      	str	r4, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_6;
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_3;
 80019e2:	931b      	str	r3, [sp, #108]	; 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80019e4:	f7fe ff24 	bl	8000830 <HAL_RCC_OscConfig>
 80019e8:	2800      	cmp	r0, #0
 80019ea:	d000      	beq.n	80019ee <SystemClock_Config+0x3e>
 80019ec:	e7fe      	b.n	80019ec <SystemClock_Config+0x3c>
    Error_Handler();
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80019ee:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80019f0:	9002      	str	r0, [sp, #8]
    Error_Handler();
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80019f2:	9300      	str	r3, [sp, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80019f4:	9003      	str	r0, [sp, #12]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80019f6:	3b0c      	subs	r3, #12
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80019f8:	9004      	str	r0, [sp, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 80019fa:	0029      	movs	r1, r5
 80019fc:	4668      	mov	r0, sp

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80019fe:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8001a00:	f7ff f9cc 	bl	8000d9c <HAL_RCC_ClockConfig>
 8001a04:	2800      	cmp	r0, #0
 8001a06:	d000      	beq.n	8001a0a <SystemClock_Config+0x5a>
 8001a08:	e7fe      	b.n	8001a08 <SystemClock_Config+0x58>
  {
    Error_Handler();
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8001a0a:	9008      	str	r0, [sp, #32]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001a0c:	a805      	add	r0, sp, #20
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8001a0e:	9405      	str	r4, [sp, #20]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001a10:	f7ff fa9e 	bl	8000f50 <HAL_RCCEx_PeriphCLKConfig>
 8001a14:	1e04      	subs	r4, r0, #0
 8001a16:	d000      	beq.n	8001a1a <SystemClock_Config+0x6a>
 8001a18:	e7fe      	b.n	8001a18 <SystemClock_Config+0x68>
    Error_Handler();
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001a1a:	f7ff fa73 	bl	8000f04 <HAL_RCC_GetHCLKFreq>
 8001a1e:	21fa      	movs	r1, #250	; 0xfa
 8001a20:	0089      	lsls	r1, r1, #2
 8001a22:	f7fe fb7b 	bl	800011c <__aeabi_uidiv>
 8001a26:	f7fe fd87 	bl	8000538 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8001a2a:	2004      	movs	r0, #4
 8001a2c:	f7fe fd9e 	bl	800056c <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8001a30:	2001      	movs	r0, #1
 8001a32:	0022      	movs	r2, r4
 8001a34:	0021      	movs	r1, r4
 8001a36:	4240      	negs	r0, r0
 8001a38:	f7fe fd44 	bl	80004c4 <HAL_NVIC_SetPriority>
}
 8001a3c:	b01d      	add	sp, #116	; 0x74
 8001a3e:	bd30      	pop	{r4, r5, pc}
 8001a40:	40007000 	.word	0x40007000
 8001a44:	ffffe7ff 	.word	0xffffe7ff

08001a48 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8001a48:	b530      	push	{r4, r5, lr}
 8001a4a:	b089      	sub	sp, #36	; 0x24
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8001a4c:	f7fe fd10 	bl	8000470 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 8001a50:	f7ff ffae 	bl	80019b0 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001a54:	2202      	movs	r2, #2
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a56:	2401      	movs	r4, #1

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);
 8001a58:	25e0      	movs	r5, #224	; 0xe0
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001a5a:	4b26      	ldr	r3, [pc, #152]	; (8001af4 <main+0xac>)
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);
 8001a5c:	01ed      	lsls	r5, r5, #7
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001a5e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);
 8001a60:	4825      	ldr	r0, [pc, #148]	; (8001af8 <main+0xb0>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001a62:	4311      	orrs	r1, r2
 8001a64:	62d9      	str	r1, [r3, #44]	; 0x2c
 8001a66:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001a68:	400a      	ands	r2, r1
 8001a6a:	9201      	str	r2, [sp, #4]
 8001a6c:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a6e:	6ada      	ldr	r2, [r3, #44]	; 0x2c

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);
 8001a70:	0029      	movs	r1, r5

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a72:	4322      	orrs	r2, r4
 8001a74:	62da      	str	r2, [r3, #44]	; 0x2c
 8001a76:	6adb      	ldr	r3, [r3, #44]	; 0x2c

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);
 8001a78:	2200      	movs	r2, #0

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a7a:	4023      	ands	r3, r4
 8001a7c:	9302      	str	r3, [sp, #8]
 8001a7e:	9b02      	ldr	r3, [sp, #8]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);
 8001a80:	f7fe fe94 	bl	80007ac <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PB14 PB13 PB12 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001a84:	9404      	str	r4, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a86:	2400      	movs	r4, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001a88:	481b      	ldr	r0, [pc, #108]	; (8001af8 <main+0xb0>)
 8001a8a:	a903      	add	r1, sp, #12

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB14 PB13 PB12 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_13|GPIO_PIN_12;
 8001a8c:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a8e:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a90:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001a92:	f7fe fdcf 	bl	8000634 <HAL_GPIO_Init>

/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 8001a96:	4819      	ldr	r0, [pc, #100]	; (8001afc <main+0xb4>)
 8001a98:	4b19      	ldr	r3, [pc, #100]	; (8001b00 <main+0xb8>)
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_7B;
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001a9a:	60c4      	str	r4, [r0, #12]

/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 8001a9c:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = 115200;
 8001a9e:	23e1      	movs	r3, #225	; 0xe1
 8001aa0:	025b      	lsls	r3, r3, #9
 8001aa2:	6043      	str	r3, [r0, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_7B;
 8001aa4:	2380      	movs	r3, #128	; 0x80
 8001aa6:	055b      	lsls	r3, r3, #21
 8001aa8:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001aaa:	230c      	movs	r3, #12

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_7B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
 8001aac:	6104      	str	r4, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001aae:	6143      	str	r3, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001ab0:	6184      	str	r4, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8001ab2:	61c4      	str	r4, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001ab4:	6204      	str	r4, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001ab6:	6244      	str	r4, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001ab8:	f7ff ff42 	bl	8001940 <HAL_UART_Init>
 8001abc:	42a0      	cmp	r0, r4
 8001abe:	d000      	beq.n	8001ac2 <main+0x7a>
 8001ac0:	e7fe      	b.n	8001ac0 <main+0x78>
  while (1)
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
		HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_14);
 8001ac2:	2180      	movs	r1, #128	; 0x80
 8001ac4:	480c      	ldr	r0, [pc, #48]	; (8001af8 <main+0xb0>)
 8001ac6:	01c9      	lsls	r1, r1, #7
 8001ac8:	f7fe fe76 	bl	80007b8 <HAL_GPIO_TogglePin>
		HAL_Delay(100);
 8001acc:	2064      	movs	r0, #100	; 0x64
 8001ace:	f7fe fced 	bl	80004ac <HAL_Delay>
		HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_13);
 8001ad2:	2180      	movs	r1, #128	; 0x80
 8001ad4:	4808      	ldr	r0, [pc, #32]	; (8001af8 <main+0xb0>)
 8001ad6:	0189      	lsls	r1, r1, #6
 8001ad8:	f7fe fe6e 	bl	80007b8 <HAL_GPIO_TogglePin>
		HAL_Delay(100);
 8001adc:	2064      	movs	r0, #100	; 0x64
 8001ade:	f7fe fce5 	bl	80004ac <HAL_Delay>
		HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_12);
 8001ae2:	2180      	movs	r1, #128	; 0x80
 8001ae4:	4804      	ldr	r0, [pc, #16]	; (8001af8 <main+0xb0>)
 8001ae6:	0149      	lsls	r1, r1, #5
 8001ae8:	f7fe fe66 	bl	80007b8 <HAL_GPIO_TogglePin>
		HAL_Delay(100);
 8001aec:	2064      	movs	r0, #100	; 0x64
 8001aee:	f7fe fcdd 	bl	80004ac <HAL_Delay>
 8001af2:	e7e6      	b.n	8001ac2 <main+0x7a>
 8001af4:	40021000 	.word	0x40021000
 8001af8:	50000400 	.word	0x50000400
 8001afc:	20000024 	.word	0x20000024
 8001b00:	40004400 	.word	0x40004400

08001b04 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b04:	2101      	movs	r1, #1
 8001b06:	4b12      	ldr	r3, [pc, #72]	; (8001b50 <HAL_MspInit+0x4c>)
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001b08:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b0a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();

  /* System interrupt init*/
  /* SVC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVC_IRQn, 0, 0);
 8001b0c:	2005      	movs	r0, #5
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b0e:	430a      	orrs	r2, r1
  __HAL_RCC_PWR_CLK_ENABLE();
 8001b10:	2180      	movs	r1, #128	; 0x80
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b12:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 8001b14:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001b16:	0549      	lsls	r1, r1, #21
 8001b18:	430a      	orrs	r2, r1
 8001b1a:	639a      	str	r2, [r3, #56]	; 0x38

  /* System interrupt init*/
  /* SVC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVC_IRQn, 0, 0);
 8001b1c:	2200      	movs	r2, #0
 8001b1e:	4240      	negs	r0, r0
 8001b20:	0011      	movs	r1, r2
 8001b22:	f7fe fccf 	bl	80004c4 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8001b26:	2200      	movs	r2, #0
 8001b28:	2002      	movs	r0, #2
 8001b2a:	0011      	movs	r1, r2
 8001b2c:	4240      	negs	r0, r0
 8001b2e:	f7fe fcc9 	bl	80004c4 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8001b32:	2200      	movs	r2, #0
 8001b34:	2001      	movs	r0, #1
 8001b36:	0011      	movs	r1, r2
 8001b38:	4240      	negs	r0, r0
 8001b3a:	f7fe fcc3 	bl	80004c4 <HAL_NVIC_SetPriority>

  /* Peripheral interrupt init*/
  /* RCC_CRS_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_CRS_IRQn, 0, 0);
 8001b3e:	2200      	movs	r2, #0
 8001b40:	2004      	movs	r0, #4
 8001b42:	0011      	movs	r1, r2
 8001b44:	f7fe fcbe 	bl	80004c4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_CRS_IRQn);
 8001b48:	2004      	movs	r0, #4
 8001b4a:	f7fe fceb 	bl	8000524 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001b4e:	bd10      	pop	{r4, pc}
 8001b50:	40021000 	.word	0x40021000

08001b54 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001b54:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8001b56:	6802      	ldr	r2, [r0, #0]
 8001b58:	4b10      	ldr	r3, [pc, #64]	; (8001b9c <HAL_UART_MspInit+0x48>)
 8001b5a:	429a      	cmp	r2, r3
 8001b5c:	d11c      	bne.n	8001b98 <HAL_UART_MspInit+0x44>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8001b5e:	2180      	movs	r1, #128	; 0x80
 8001b60:	4a0f      	ldr	r2, [pc, #60]	; (8001ba0 <HAL_UART_MspInit+0x4c>)
 8001b62:	0289      	lsls	r1, r1, #10
 8001b64:	6b93      	ldr	r3, [r2, #56]	; 0x38
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b66:	20a0      	movs	r0, #160	; 0xa0
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8001b68:	430b      	orrs	r3, r1
 8001b6a:	6393      	str	r3, [r2, #56]	; 0x38
  
    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8001b6c:	230c      	movs	r3, #12
 8001b6e:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b70:	3b0a      	subs	r3, #10
 8001b72:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001b74:	3b01      	subs	r3, #1
 8001b76:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b78:	3302      	adds	r3, #2
 8001b7a:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b7c:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_USART2;
 8001b7e:	3301      	adds	r3, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b80:	05c0      	lsls	r0, r0, #23
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_USART2;
 8001b82:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b84:	f7fe fd56 	bl	8000634 <HAL_GPIO_Init>

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 8001b88:	2200      	movs	r2, #0
 8001b8a:	201c      	movs	r0, #28
 8001b8c:	0011      	movs	r1, r2
 8001b8e:	f7fe fc99 	bl	80004c4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8001b92:	201c      	movs	r0, #28
 8001b94:	f7fe fcc6 	bl	8000524 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 8001b98:	b007      	add	sp, #28
 8001b9a:	bd00      	pop	{pc}
 8001b9c:	40004400 	.word	0x40004400
 8001ba0:	40021000 	.word	0x40021000

08001ba4 <NMI_Handler>:
 8001ba4:	4770      	bx	lr

08001ba6 <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 8001ba6:	e7fe      	b.n	8001ba6 <HardFault_Handler>

08001ba8 <SVC_Handler>:
 8001ba8:	4770      	bx	lr

08001baa <PendSV_Handler>:
 8001baa:	4770      	bx	lr

08001bac <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8001bac:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001bae:	f7fe fc6f 	bl	8000490 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
 8001bb2:	f7fe fcea 	bl	800058a <HAL_SYSTICK_IRQHandler>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001bb6:	bd10      	pop	{r4, pc}

08001bb8 <RCC_CRS_IRQHandler>:

  /* USER CODE END RCC_CRS_IRQn 0 */
  /* USER CODE BEGIN RCC_CRS_IRQn 1 */

  /* USER CODE END RCC_CRS_IRQn 1 */
}
 8001bb8:	4770      	bx	lr
	...

08001bbc <USART2_IRQHandler>:

/**
* @brief This function handles USART2 global interrupt / USART2 wake-up interrupt through EXTI line 26.
*/
void USART2_IRQHandler(void)
{
 8001bbc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8001bbe:	4802      	ldr	r0, [pc, #8]	; (8001bc8 <USART2_IRQHandler+0xc>)
 8001bc0:	f7ff fbea 	bl	8001398 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 8001bc4:	bd10      	pop	{r4, pc}
 8001bc6:	46c0      	nop			; (mov r8, r8)
 8001bc8:	20000024 	.word	0x20000024

08001bcc <SystemInit>:
  * @retval None
  */
void SystemInit (void)
{    
/*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100U;
 8001bcc:	2180      	movs	r1, #128	; 0x80
 8001bce:	4b10      	ldr	r3, [pc, #64]	; (8001c10 <SystemInit+0x44>)
 8001bd0:	0049      	lsls	r1, r1, #1
 8001bd2:	681a      	ldr	r2, [r3, #0]
 8001bd4:	430a      	orrs	r2, r1
 8001bd6:	601a      	str	r2, [r3, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t) 0x88FF400CU;
 8001bd8:	68d9      	ldr	r1, [r3, #12]
 8001bda:	4a0e      	ldr	r2, [pc, #56]	; (8001c14 <SystemInit+0x48>)
 8001bdc:	400a      	ands	r2, r1
 8001bde:	60da      	str	r2, [r3, #12]
 
  /*!< Reset HSION, HSIDIVEN, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFF6U;
 8001be0:	6819      	ldr	r1, [r3, #0]
 8001be2:	4a0d      	ldr	r2, [pc, #52]	; (8001c18 <SystemInit+0x4c>)
 8001be4:	400a      	ands	r2, r1
  
  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 8001be6:	2101      	movs	r1, #1

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t) 0x88FF400CU;
 
  /*!< Reset HSION, HSIDIVEN, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFF6U;
 8001be8:	601a      	str	r2, [r3, #0]
  
  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 8001bea:	689a      	ldr	r2, [r3, #8]
 8001bec:	438a      	bics	r2, r1
 8001bee:	609a      	str	r2, [r3, #8]
  
  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8001bf0:	6819      	ldr	r1, [r3, #0]
 8001bf2:	4a0a      	ldr	r2, [pc, #40]	; (8001c1c <SystemInit+0x50>)
 8001bf4:	400a      	ands	r2, r1
 8001bf6:	601a      	str	r2, [r3, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFFU;
 8001bf8:	68d9      	ldr	r1, [r3, #12]
 8001bfa:	4a09      	ldr	r2, [pc, #36]	; (8001c20 <SystemInit+0x54>)
 8001bfc:	400a      	ands	r2, r1
 8001bfe:	60da      	str	r2, [r3, #12]

  /*!< Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8001c00:	2200      	movs	r2, #0
 8001c02:	611a      	str	r2, [r3, #16]
  
  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8001c04:	2280      	movs	r2, #128	; 0x80
 8001c06:	4b07      	ldr	r3, [pc, #28]	; (8001c24 <SystemInit+0x58>)
 8001c08:	0512      	lsls	r2, r2, #20
 8001c0a:	609a      	str	r2, [r3, #8]
#endif
}
 8001c0c:	4770      	bx	lr
 8001c0e:	46c0      	nop			; (mov r8, r8)
 8001c10:	40021000 	.word	0x40021000
 8001c14:	88ff400c 	.word	0x88ff400c
 8001c18:	fef6fff6 	.word	0xfef6fff6
 8001c1c:	fffbffff 	.word	0xfffbffff
 8001c20:	ff02ffff 	.word	0xff02ffff
 8001c24:	e000ed00 	.word	0xe000ed00

08001c28 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 8001c28:	480d      	ldr	r0, [pc, #52]	; (8001c60 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 8001c2a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 8001c2c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8001c2e:	e003      	b.n	8001c38 <LoopCopyDataInit>

08001c30 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8001c30:	4b0c      	ldr	r3, [pc, #48]	; (8001c64 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
 8001c32:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8001c34:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8001c36:	3104      	adds	r1, #4

08001c38 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 8001c38:	480b      	ldr	r0, [pc, #44]	; (8001c68 <LoopForever+0xa>)
  ldr  r3, =_edata
 8001c3a:	4b0c      	ldr	r3, [pc, #48]	; (8001c6c <LoopForever+0xe>)
  adds  r2, r0, r1
 8001c3c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8001c3e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8001c40:	d3f6      	bcc.n	8001c30 <CopyDataInit>
  ldr  r2, =_sbss
 8001c42:	4a0b      	ldr	r2, [pc, #44]	; (8001c70 <LoopForever+0x12>)
  b  LoopFillZerobss
 8001c44:	e002      	b.n	8001c4c <LoopFillZerobss>

08001c46 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 8001c46:	2300      	movs	r3, #0
  str  r3, [r2]
 8001c48:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001c4a:	3204      	adds	r2, #4

08001c4c <LoopFillZerobss>:


LoopFillZerobss:
  ldr  r3, = _ebss
 8001c4c:	4b09      	ldr	r3, [pc, #36]	; (8001c74 <LoopForever+0x16>)
  cmp  r2, r3
 8001c4e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8001c50:	d3f9      	bcc.n	8001c46 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8001c52:	f7ff ffbb 	bl	8001bcc <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001c56:	f000 f811 	bl	8001c7c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001c5a:	f7ff fef5 	bl	8001a48 <main>

08001c5e <LoopForever>:

LoopForever:
    b LoopForever
 8001c5e:	e7fe      	b.n	8001c5e <LoopForever>

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 8001c60:	20005000 	.word	0x20005000
/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8001c64:	08001d24 	.word	0x08001d24
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4

LoopCopyDataInit:
  ldr  r0, =_sdata
 8001c68:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8001c6c:	20000004 	.word	0x20000004
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8001c70:	20000004 	.word	0x20000004
  str  r3, [r2]
  adds r2, r2, #4


LoopFillZerobss:
  ldr  r3, = _ebss
 8001c74:	20000094 	.word	0x20000094

08001c78 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001c78:	e7fe      	b.n	8001c78 <ADC1_COMP_IRQHandler>
	...

08001c7c <__libc_init_array>:
 8001c7c:	4b0e      	ldr	r3, [pc, #56]	; (8001cb8 <__libc_init_array+0x3c>)
 8001c7e:	b570      	push	{r4, r5, r6, lr}
 8001c80:	2500      	movs	r5, #0
 8001c82:	001e      	movs	r6, r3
 8001c84:	4c0d      	ldr	r4, [pc, #52]	; (8001cbc <__libc_init_array+0x40>)
 8001c86:	1ae4      	subs	r4, r4, r3
 8001c88:	10a4      	asrs	r4, r4, #2
 8001c8a:	42a5      	cmp	r5, r4
 8001c8c:	d004      	beq.n	8001c98 <__libc_init_array+0x1c>
 8001c8e:	00ab      	lsls	r3, r5, #2
 8001c90:	58f3      	ldr	r3, [r6, r3]
 8001c92:	4798      	blx	r3
 8001c94:	3501      	adds	r5, #1
 8001c96:	e7f8      	b.n	8001c8a <__libc_init_array+0xe>
 8001c98:	f000 f816 	bl	8001cc8 <_init>
 8001c9c:	4b08      	ldr	r3, [pc, #32]	; (8001cc0 <__libc_init_array+0x44>)
 8001c9e:	2500      	movs	r5, #0
 8001ca0:	001e      	movs	r6, r3
 8001ca2:	4c08      	ldr	r4, [pc, #32]	; (8001cc4 <__libc_init_array+0x48>)
 8001ca4:	1ae4      	subs	r4, r4, r3
 8001ca6:	10a4      	asrs	r4, r4, #2
 8001ca8:	42a5      	cmp	r5, r4
 8001caa:	d004      	beq.n	8001cb6 <__libc_init_array+0x3a>
 8001cac:	00ab      	lsls	r3, r5, #2
 8001cae:	58f3      	ldr	r3, [r6, r3]
 8001cb0:	4798      	blx	r3
 8001cb2:	3501      	adds	r5, #1
 8001cb4:	e7f8      	b.n	8001ca8 <__libc_init_array+0x2c>
 8001cb6:	bd70      	pop	{r4, r5, r6, pc}
 8001cb8:	08001d1c 	.word	0x08001d1c
 8001cbc:	08001d1c 	.word	0x08001d1c
 8001cc0:	08001d1c 	.word	0x08001d1c
 8001cc4:	08001d20 	.word	0x08001d20

08001cc8 <_init>:
 8001cc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001cca:	46c0      	nop			; (mov r8, r8)
 8001ccc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001cce:	bc08      	pop	{r3}
 8001cd0:	469e      	mov	lr, r3
 8001cd2:	4770      	bx	lr

08001cd4 <_fini>:
 8001cd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001cd6:	46c0      	nop			; (mov r8, r8)
 8001cd8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001cda:	bc08      	pop	{r3}
 8001cdc:	469e      	mov	lr, r3
 8001cde:	4770      	bx	lr
